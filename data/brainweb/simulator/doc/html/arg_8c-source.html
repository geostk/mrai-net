<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SIMRI3D: arg.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>arg.c</h1><a href="arg_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*************************************************************************</span>
00002 <span class="comment">* $Id: arg.c,v 1.1 2005/09/09 08:22:21 bellet Exp $</span>
00003 <span class="comment">**************************************************************************</span>
00004 <span class="comment"> This software is governed by the CeCILL  license under French law and</span>
00005 <span class="comment">  abiding by the rules of distribution of free software.  You can  use, </span>
00006 <span class="comment">  modify and/ or redistribute the software under the terms of the CeCILL</span>
00007 <span class="comment">  license as circulated by CEA, CNRS and INRIA at the following URL</span>
00008 <span class="comment">  "http://www.cecill.info". </span>
00009 <span class="comment">  </span>
00010 <span class="comment">  As a counterpart to the access to the source code and  rights to copy,</span>
00011 <span class="comment">  modify and redistribute granted by the license, users are provided only</span>
00012 <span class="comment">  with a limited warranty  and the software's author,  the holder of the</span>
00013 <span class="comment">  economic rights,  and the successive licensors  have only  limited</span>
00014 <span class="comment">  liability. </span>
00015 <span class="comment">  </span>
00016 <span class="comment">  In this respect, the user's attention is drawn to the risks associated</span>
00017 <span class="comment">  with loading,  using,  modifying and/or developing or reproducing the</span>
00018 <span class="comment">  software by the user in light of its specific status of free software,</span>
00019 <span class="comment">  that may mean  that it is complicated to manipulate,  and  that  also</span>
00020 <span class="comment">  therefore means  that it is reserved for developers  and  experienced</span>
00021 <span class="comment">  professionals having in-depth computer knowledge. Users are therefore</span>
00022 <span class="comment">  encouraged to load and test the software's suitability as regards their</span>
00023 <span class="comment">  requirements in conditions enabling the security of their systems and/or </span>
00024 <span class="comment">  data to be ensured and,  more generally, to use and operate it in the </span>
00025 <span class="comment">  same conditions as regards security. </span>
00026 <span class="comment">  </span>
00027 <span class="comment">  The fact that you are presently reading this means that you have had</span>
00028 <span class="comment">  knowledge of the CeCILL license and that you accept its terms.</span>
00029 <span class="comment">  </span>
00030 <span class="comment">  Copyright (c) CREATIS (Centre de Recherche et d'Applications en Traitement de</span>
00031 <span class="comment">  l'Image). All rights reserved. See License.txt for details.</span>
00032 <span class="comment">  </span>
00033 <span class="comment">  Version 1.0  05/09/2005</span>
00034 <span class="comment">*************************************************************************/</span>
00035 
00036 <span class="comment">/*************************************************************************</span>
00037 <span class="comment">*</span>
00038 <span class="comment">*  Description : Gestion simplifiee des arguments passes sur la ligne </span>
00039 <span class="comment">*                de commande.</span>
00040 <span class="comment">*</span>
00041 <span class="comment">**************************************************************************/</span>
00042 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00043 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00044 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00045 <span class="preprocessor">#include &lt;string.h&gt;</span>  <span class="comment">// For strlen</span>
00046 <span class="preprocessor">#include "<a class="code" href="idarg_8h.html">idarg.h</a>"</span>
00047 <span class="preprocessor">#include "<a class="code" href="iderr_8h.html">iderr.h</a>"</span>
00048 <span class="preprocessor">#include "<a class="code" href="idprint_8h.html">idprint.h</a>"</span>
00049 <span class="preprocessor">#include "<a class="code" href="idio_8h.html">idio.h</a>"</span>
00050 
<a name="l00051"></a><a class="code" href="arg_8c.html#a0">00051</a> <span class="preprocessor">#define  ARG_LONG_MAX          1000 </span><span class="comment">/* JPR, au lieu de 100 */</span>
00052 
00053 <span class="comment">/* VERS     1.02 *********************************************************/</span>
<a name="l00054"></a><a class="code" href="arg_8c.html#a1">00054</a> <span class="preprocessor">#define  ARG_LABEL_LOGFILE       "LOG"</span>
<a name="l00055"></a><a class="code" href="arg_8c.html#a2">00055</a> <span class="preprocessor"></span><span class="preprocessor">#define  ARG_LABEL_PARAMOUT      "paramout"</span>
00056 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">char</span> * ArgParamOut;              <span class="comment">/* Nom du fichier de sortie param*/</span>
00057 <span class="comment">/* Fin ******************************************************************/</span>
00058 
00059 
00060 <span class="keyword">static</span> <span class="keywordtype">char</span> * ArgUsed = 0;              <span class="comment">/* Arguments utilises            */</span>
00061 <span class="keyword">static</span> <span class="keywordtype">char</span> * ArgLab[<a class="code" href="idarg_8h.html#a0">ARGMAXCOUNT</a>];      <span class="comment">/* Liste des labels d'arguments  */</span>
00062 <span class="keyword">static</span> <span class="keywordtype">char</span> * ArgStr[<a class="code" href="idarg_8h.html#a0">ARGMAXCOUNT</a>];      <span class="comment">/* Liste des chaines d'arguments */</span>
00063 <span class="keyword">static</span> <span class="keywordtype">int</span>    ArgCount = 0;             <span class="comment">/* Nombre d'arguments passes     */</span>
00064 <span class="keyword">static</span> <span class="keywordtype">char</span> * Appel = 0;                <span class="comment">/* globale pour liberation par   */</span>
00065                <span class="comment">/* argfree    */</span>   <span class="comment">/* CO 14/4/92 */</span>
00066 
00067 <span class="comment">/* Prototypes ***************************************** Version 1.03 CM **/</span>
00068 
00069 <span class="keyword">static</span> <span class="keywordtype">char</span> * Majuscule       (<span class="keywordtype">char</span>*);
00070 <span class="keyword">static</span> <span class="keywordtype">int</span>    FiltreLong      (<span class="keywordtype">char</span>*);
00071 <span class="keyword">static</span> <span class="keywordtype">char</span> * LoadedParam     (<span class="keywordtype">char</span>*,FILE*);
00072 <span class="keyword">static</span> <span class="keywordtype">int</span>    ArgLoadFromFile (<span class="keywordtype">char</span>*);
00073 <span class="keyword">static</span> <span class="keywordtype">void</span>   ArgStdArgs      (<span class="keywordtype">void</span>);
00074 
00075 <span class="comment">/* Version 1.03 **********************************************************/</span>
00076 <span class="comment">/**************************************************************************</span>
00077 <span class="comment">*                                                                         *</span>
00078 <span class="comment">* Nom de la fonction : Majuscule                                          *</span>
00079 <span class="comment">* Role ............. : Met une chaine de caracteres en majuscules.        *</span>
00080 <span class="comment">* Parametres ....... : Pointeur vers la chaine.                           *</span>
00081 <span class="comment">* Valeur retournee . : pointeur vers cette meme chaine en majuscule.      *</span>
00082 <span class="comment">*                                                                         *</span>
00083 <span class="comment">**************************************************************************/</span>
00084 <span class="keyword">static</span> <span class="keywordtype">char</span> *
00085 Majuscule (chaine )
00086   char * chaine;
00087 {
00088   <span class="keywordtype">char</span> * ptr, *ptr2, *ptr3;
00089   ptr2 = malloc(strlen(chaine)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)+1);<span class="comment">/*bb 30Mai95*/</span>
00090   ptr3=ptr2;
00091 
00092   <span class="keywordflow">for</span> ( ptr = chaine ; *ptr!=<span class="charliteral">'\0'</span> ; ptr ++ ) 
00093    {  *ptr3 = toupper ( * ptr ); ptr3++; 
00094    }
00095   *ptr3=<span class="charliteral">'\0'</span>;
00096  
00097   <span class="keywordflow">return</span> ptr2;
00098 }
00099 
00100 <span class="comment">/**************************************************************************</span>
00101 <span class="comment">*                                                                         *</span>
00102 <span class="comment">* Nom de la fonction : FiltreLong                                         *</span>
00103 <span class="comment">* Role ............. : Arrete le programme si l'argument est trop long.   *</span>
00104 <span class="comment">*                      ARG_LONG_MAX definit cette longueur.               *</span>
00105 <span class="comment">* Parametres ....... : Pointeur vers l'argument.                          *</span>
00106 <span class="comment">* Valeur retournee . : Faux s'il n'y a pas d'erreur.                      *</span>
00107 <span class="comment">*                      Vrai s'il y a une erreur.                          *</span>
00108 <span class="comment">**************************************************************************/</span>
00109 <span class="keyword">static</span> <span class="keywordtype">int</span>
00110 FiltreLong (arg  )
00111   char * arg;
00112 {
00113   <span class="keywordtype">int</span>  n = 0 ;
00114   <span class="keywordflow">while</span> ( (n++&lt;<a class="code" href="arg_8c.html#a0">ARG_LONG_MAX</a>) &amp;&amp; (*(arg++) != <span class="charliteral">'\0'</span>) ) ;
00115   <span class="keywordflow">return</span> (n&gt;=<a class="code" href="arg_8c.html#a0">ARG_LONG_MAX</a>) ;
00116 }
00117 
00118 
00119 
00120 <span class="comment">/* VERS 1.02 *********************************************************/</span>
00121 <span class="comment">/*------------------------------------------------------------------------</span>
00122 <span class="comment"> | Role       : Lit un parametre depuis un fichier</span>
00123 <span class="comment"> | Retour     : Type   : char *</span>
00124 <span class="comment"> |              Role   : pointeur vers le label</span>
00125 <span class="comment"> | Parametres : param  : char *</span>
00126 <span class="comment"> |              Role   : one ou il faut stocker le parametre</span>
00127 <span class="comment"> |              fd     : FILE *</span>
00128 <span class="comment"> |              Role   : descripteur du fichier (suppose ouvert)</span>
00129 <span class="comment"> |</span>
00130 <span class="comment"> +------------------------------------------------------------------------*/</span>
00131 <span class="keyword">static</span> <span class="keywordtype">char</span> *
00132 LoadedParam ( param, fd )
00133   char * param;
00134   FILE *fd;
00135 {
00136   <span class="keywordtype">int</span>    carlu;
00137   <span class="keywordtype">char</span> * car = param;
00138   <span class="keywordtype">int</span>    quote = <a class="code" href="idarg_8h.html#a3">FALSE</a>;
00139   <span class="keywordtype">int</span>    nbcar = 0;
00140 
00141                  <span class="comment">/* On supprime les espaces ****/</span>
00142                  <span class="comment">/* du debut de chaine *********/</span>
00143   <span class="keywordflow">while</span> ( isspace(carlu=fgetc (fd)) );
00144   <span class="keywordflow">if</span> (carlu==EOF) <span class="keywordflow">return</span> 0;
00145                  <span class="comment">/* On cherche une " eventuelle*/</span>
00146   <span class="keywordflow">if</span> ( carlu==<span class="charliteral">'\"'</span> ) {
00147     carlu=fgetc(fd);
00148     quote=<a class="code" href="idarg_8h.html#a4">TRUE</a>;
00149                  <span class="comment">/* On lit tous les caracteres */</span>
00150   }
00151   <span class="keywordflow">while</span> (  (carlu!=EOF)
00152    &amp;&amp; (  ( (!quote)&amp;&amp;(!isspace(carlu)) )
00153        ||( (quote)&amp;&amp; !(carlu==<span class="charliteral">'\"'</span>)   ) ) ) {
00154     *(car++) = (<span class="keywordtype">char</span>) carlu;
00155     nbcar ++;
00156                  <span class="comment">/* sans depasser la taille max*/</span>
00157     <span class="keywordflow">if</span> ( nbcar &gt;= <a class="code" href="arg_8c.html#a0">ARG_LONG_MAX</a> ) {
00158       <a class="code" href="kerprint_8c.html#a5">IdErrPrintf</a>(<span class="stringliteral">"\nErreur: Argument trop long ( &gt; %d )dans fichier de parametre."</span>,ARG_LONG_MAX);
00159       <span class="keywordflow">break</span>;
00160     }
00161     carlu = fgetc(fd);
00162   }
00163   *car = <span class="charliteral">'\0'</span>;
00164   <span class="keywordflow">return</span> param;
00165 }
00166 
00167 
00168 <span class="comment">/* VERS 1.02 *********************************************************/</span>
00169 <span class="comment">/*------------------------------------------------------------------------</span>
00170 <span class="comment"> | Role       : Lecture d'arguments dans un fichier de parametres</span>
00171 <span class="comment"> |              (cette fonction est recursive).</span>
00172 <span class="comment"> | Retour     : Type   : int</span>
00173 <span class="comment"> |              Role   : retourne le nombre de lettres necessaires</span>
00174 <span class="comment"> |                       pour stocker en memoire tous les parametres</span>
00175 <span class="comment"> | Parametres : filename : char *</span>
00176 <span class="comment"> |              Role     : nom du fichier de parametre</span>
00177 <span class="comment"> |</span>
00178 <span class="comment"> +------------------------------------------------------------------------*/</span>
00179 <span class="keyword">static</span> <span class="keywordtype">int</span>
00180 ArgLoadFromFile ( filename )
00181 char    * filename ;
00182 {
00183   <span class="keywordtype">int</span>   nbl = 0;
00184   <span class="keywordtype">char</span>  param[<a class="code" href="arg_8c.html#a0">ARG_LONG_MAX</a>+1];
00185   FILE  * fch;
00186 
00187   fch = fopen ( filename, ID_RFILE_TEXT );
00188   <span class="keywordflow">while</span> ( LoadedParam (param, fch ) ) {
00189     <span class="keywordtype">int</span> n = strlen(param);
00190     <span class="keywordflow">if</span> ( param[0]==<span class="charliteral">'@'</span> ) {
00191       nbl  += ArgLoadFromFile ( &amp;param[1] );
00192     }<span class="keywordflow">else</span>{
00193       ArgLab [ArgCount] = strcpy ((<span class="keywordtype">char</span> *) malloc(n+1), param ) ;
00194       nbl += n + 1 ;
00195       ArgCount++;
00196       <span class="keywordflow">if</span> ( ArgCount &gt;= <a class="code" href="idarg_8h.html#a0">ARGMAXCOUNT</a> ) <span class="keywordflow">break</span>;
00197     }
00198   }
00199   fclose ( fch );
00200   <span class="keywordflow">return</span> nbl;
00201 }
00202 
00203 <span class="comment">/*------------------------------------------------------------------------</span>
00204 <span class="comment"> | Role       : Gestion des parametres standards de la ligne d'argument.</span>
00205 <span class="comment"> | Retour     : Type   : void</span>
00206 <span class="comment"> | Parametres : aucun</span>
00207 <span class="comment"> +------------------------------------------------------------------------*/</span>
00208 <span class="keyword">static</span> <span class="keywordtype">void</span>
00209 ArgStdArgs()
00210 {
00211   <span class="keywordtype">char</span> * logfile;
00212   FILE * fd;
00213 
00214   <span class="keywordflow">if</span> ( (ArgParamOut=<a class="code" href="idarg_8h.html#a15">IdArgValue</a>(ARG_LABEL_PARAMOUT))==0 )         <span class="comment">/* V1.02 */</span>
00215     ArgParamOut = <a class="code" href="idarg_8h.html#a1">ARG_DEFAULT_PARAMOUT</a>;                          <span class="comment">/* V1.02 */</span>
00216 
00217   <span class="keywordflow">if</span> ( (logfile = <a class="code" href="idarg_8h.html#a15">IdArgValue</a>(ARG_LABEL_LOGFILE))!=0) 
00218   {
00219     <span class="keywordflow">if</span> ( *logfile == <span class="charliteral">'\0'</span> ) logfile = <a class="code" href="idarg_8h.html#a2">ARG_DEFAULT_LOGFILE</a>;
00220     fd = fopen ( logfile, <span class="stringliteral">"a+"</span> );
00221     <span class="keywordflow">if</span> ( fd ) 
00222     {
00223       fprintf ( fd, <span class="stringliteral">"%s\n"</span>, Appel );
00224       fclose  ( fd );
00225     }
00226   }
00227 }
00228 
00229 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00230 <span class="comment">*</span>
00231 <span class="comment">*IdArgInit   (fonction)</span>
00232 <span class="comment">*</span>
00233 <span class="comment">* RESUME: Initialise le gestionnaire d'arguments des filtres LIBIDO.</span>
00234 <span class="comment">*</span>
00235 <span class="comment">* DESCRIPTION: Initialise le gestionnaire d'arguments des filtres LIBIDO.</span>
00236 <span class="comment">*              Pour plus d'informations, se reporter a la description des</span>
00237 <span class="comment">*              filtres de LIBIDO (manuel de l'utilisateur, et developpement).</span>
00238 <span class="comment">*</span>
00239 <span class="comment">* SYNTAXE:    char * ligneAppel = IdArgInit (int argc, char **argv) ;</span>
00240 <span class="comment">*</span>
00241 <span class="comment">* RETOUR:     type  : char *</span>
00242 <span class="comment">*             role  : Pointeur vers une chaine contenant la ligne complete</span>
00243 <span class="comment">*                     d'appel du filtre. Les fichiers de parametres sont</span>
00244 <span class="comment">*                     developpees dans cette lignes.</span>
00245 <span class="comment">* PARAMETRES:</span>
00246 <span class="comment">*            nom   : argc</span>
00247 <span class="comment">*            type  : int</span>
00248 <span class="comment">*            role  : Nombre d'arguments passes a la fonction main.</span>
00249 <span class="comment">*</span>
00250 <span class="comment">*            nom   : argv</span>
00251 <span class="comment">*            type  : char **</span>
00252 <span class="comment">*            role  : tableau de pointeur vers les arguments passes a</span>
00253 <span class="comment">*                    la fonction main (cf: Le Langage C-Kernighan &amp; Richie).</span>
00254 <span class="comment">*</span>
00255 <span class="comment">* FICHIER:     arg.c</span>
00256 <span class="comment">*</span>
00257 <span class="comment">* EXEMPLE:</span>
00258 <span class="comment">*     #include &lt;idarg.h&gt;</span>
00259 <span class="comment">*     int</span>
00260 <span class="comment">*     main ( argc, argv )</span>
00261 <span class="comment">*     int    argc;</span>
00262 <span class="comment">*     char * argv[];</span>
00263 <span class="comment">*     {</span>
00264 <span class="comment">*  char * ligne_appel;</span>
00265 <span class="comment">*  ligne_appel = IdArgInit ( argc, argv );</span>
00266 <span class="comment">*  IdPrintf("\nAppel : \n\n%s\n\n", ligne_appel );</span>
00267 <span class="comment">*  IdExit();</span>
00268 <span class="comment">*     }</span>
00269 <span class="comment">*</span>
00270 <span class="comment">******************************************************** END DESCRIPTION */</span>
00271 
00272 <span class="comment">/**************************************************************************</span>
00273 <span class="comment">* Explication ...... : recopie des arguments de la chaine de commande     *</span>
00274 <span class="comment">*                      dans les variables statiques globales de arg.c :   *</span>
00275 <span class="comment">*                        ArgCount : nombre de parametres                  *</span>
00276 <span class="comment">*                        ArgStr[ 0..ArgCount-1] : arguments               *</span>
00277 <span class="comment">**************************************************************************/</span>
<a name="l00278"></a><a class="code" href="arg_8c.html#a15">00278</a> <span class="keywordtype">char</span> * <a class="code" href="idarg_8h.html#a13">IdArgInit</a> (argc,argv)   <span class="comment">/* On laisse comme ca  JPR */</span>
00279 int argc;
00280 <span class="keywordtype">char</span> * argv[];
00281 {
00282   <span class="keywordtype">int</span> i;
00283   <span class="keywordtype">int</span> nblettre;
00284 
00285  
00286 <span class="comment">/* Lecture des parametres de la ligne de commande *************************/</span>
00287   <span class="keywordflow">for</span> ( ArgCount=0, nblettre=1 , i=0; i&lt;argc; i++) {
00288     <span class="keywordflow">if</span> ( FiltreLong(argv[i]) ) 
00289       { 
00290       <a class="code" href="kerprint_8c.html#a5">IdErrPrintf</a>(<span class="stringliteral">"Argument trop long ( &gt; %d)...\n"</span>,<a class="code" href="arg_8c.html#a0">ARG_LONG_MAX</a>); 
00291       <span class="keywordflow">return</span> NULL;
00292       }
00293     <span class="keywordflow">if</span> ( argv[i][0] == <span class="charliteral">'@'</span> ){                                    <span class="comment">/* V1.02 */</span>
00294       nblettre  += ArgLoadFromFile ( &amp;argv[i][1] );              <span class="comment">/* V1.02 */</span>
00295     }<span class="keywordflow">else</span>{                                                       <span class="comment">/* V1.02 */</span>
00296       ArgLab [ArgCount] = strcpy ( (<span class="keywordtype">char</span> *)malloc(strlen(argv[i])+1), argv[i] ) ;
00297       nblettre  += 1 + strlen(ArgLab[ArgCount]);                 <span class="comment">/* V1.02 */</span>
00298       ArgCount++;                                                <span class="comment">/* V1.02 */</span>
00299     }
00300     <span class="keywordflow">if</span> (ArgCount &gt;= <a class="code" href="idarg_8h.html#a0">ARGMAXCOUNT</a> )                                <span class="comment">/* V1.02 */</span>
00301       {
00302        <a class="code" href="kerprint_8c.html#a5">IdErrPrintf</a>(<span class="stringliteral">"Trop d'Arguments ( + de %d)\n"</span>, <a class="code" href="idarg_8h.html#a0">ARGMAXCOUNT</a> ); 
00303           <span class="keywordflow">return</span> 0;
00304       }
00305   }
00306 
00307 <span class="comment">/* Initialisation d'un tableau memorisant les parametres deja utilises ****/</span>
00308   ArgUsed = (<span class="keywordtype">char</span> *) calloc ( 1, ArgCount );
00309 
00310 <span class="comment">/* Construction de la chaine complete des parametres d'appel **************/</span>
00311   Appel = (<span class="keywordtype">char</span> *)  calloc ( 1, nblettre );
00312 
00313   <span class="keywordflow">for</span> ( *Appel = <span class="charliteral">'\0'</span>, i=0; i&lt;ArgCount; i++) {
00314     strcat ( Appel, ArgLab [i] ) ;
00315     strcat ( Appel, <span class="stringliteral">" "</span> ) ;
00316   }
00317 
00318 <span class="comment">/* Separation du label de leur valeur *************************************/</span>
00319   <span class="keywordflow">for</span> ( i=0; i&lt;ArgCount; i++) {
00320     <span class="keywordtype">char</span> * egaloufin = ArgLab[i] ;
00321     <span class="keywordflow">while</span> ( (*egaloufin != <span class="charliteral">'\0'</span>) &amp;&amp; (*egaloufin != <span class="charliteral">'='</span>) ) egaloufin ++ ;
00322     <span class="keywordflow">if</span> ( *egaloufin ) *(egaloufin++) = <span class="charliteral">'\0'</span>;
00323     ArgStr[i]= egaloufin;
00324   }
00325 
00326 <span class="comment">/* Mise en majuscule des labels ( casse non-sensible pour label ) *********/</span>
00327   <span class="keywordflow">for</span> ( i=0; i&lt;ArgCount; i++)
00328     ArgLab[i] = Majuscule ( ArgLab[i] ) ;
00329 
00330 <span class="comment">/* Les arguments standards sont geres par ArgStdArgs **********************/</span>
00331  ArgStdArgs(); 
00332 
00333  <span class="keywordflow">return</span> Appel ;
00334 }
00335 
00336 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00337 <span class="comment"></span>
00338 <span class="comment">IdArgDefined   (fonction)</span>
00339 <span class="comment"></span>
00340 <span class="comment">RESUME: verifie si un parametre existe dans la ligne de commande</span>
00341 <span class="comment"></span>
00342 <span class="comment">DESCRIPTION: verifie si un parametre existe dans la ligne de commande</span>
00343 <span class="comment"></span>
00344 <span class="comment">SYNTAXE:     int retCode = IdArgDefined(char *label);</span>
00345 <span class="comment"></span>
00346 <span class="comment">RETOUR:      type  : int</span>
00347 <span class="comment">        role  : Vrai si le parametre 'label' existe.</span>
00348 <span class="comment">           En fait, la valeur retournee est 0 si le</span>
00349 <span class="comment">           label n'est pas trouve, sinon, c'est le numero</span>
00350 <span class="comment">           d'emplacement ou il a ete recontre pour la derniere</span>
00351 <span class="comment">           fois.</span>
00352 <span class="comment"></span>
00353 <span class="comment">PARAMETRES:</span>
00354 <span class="comment">        nom   : label</span>
00355 <span class="comment">        type  : char *</span>
00356 <span class="comment">        role  : Nom du label du parametre recherche.</span>
00357 <span class="comment"></span>
00358 <span class="comment">FICHIER:     arg.c</span>
00359 <span class="comment"></span>
00360 <span class="comment">EXEMPLE:     if ( !IdArgDefined("FILEIN") )</span>
00361 <span class="comment">      IdErrPrintf ("\nErreur: parametre non trouve");</span>
00362 <span class="comment"></span>
00363 <span class="comment">******************************************************** END DESCRIPTION */</span>
00364 <span class="keywordtype">int</span>
<a name="l00365"></a><a class="code" href="idarg_8h.html#a14">00365</a> <a class="code" href="idarg_8h.html#a14">IdArgDefined</a>(SearchParam )
00366   char * SearchParam;
00367 {
00368   <span class="keywordtype">int</span> i, Trouve ;
00369   <span class="keywordtype">char</span> *Temp;
00370 
00371   Temp =Majuscule ( SearchParam ) ;
00372 
00373   <span class="keywordflow">for</span> ( Trouve = <a class="code" href="idarg_8h.html#a3">FALSE</a>, i = ArgCount-1; i&gt;0; i-- ) {            <span class="comment">/* V1.04 */</span>
00374     Trouve = ! strcmp( ArgLab[i], Temp ) ;
00375     <span class="keywordflow">if</span> ( Trouve ) {
00376       <span class="keywordtype">int</span> j;
00377       ArgUsed[i] = <a class="code" href="idarg_8h.html#a4">TRUE</a> ;                                       <span class="comment">/* V1.04 */</span>
00378       <span class="keywordflow">for</span> ( j=1; j&lt;i; j++) {                                    <span class="comment">/* V1.04 */</span>
00379    <span class="keywordflow">if</span> ( (!ArgUsed[j])&amp;&amp;(!strcmp(ArgLab[i],ArgLab[j])) )    <span class="comment">/* V1.04 */</span>
00380      ArgUsed[j] = <a class="code" href="idarg_8h.html#a4">TRUE</a> ;
00381       }
00382       <span class="keywordflow">return</span> i ;
00383     }
00384   }
00385 
00386   <span class="keywordflow">return</span> <a class="code" href="idarg_8h.html#a3">FALSE</a> ;
00387 }
00388 
00389 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00390 <span class="comment"></span>
00391 <span class="comment">IdArgValue   (fonction)</span>
00392 <span class="comment"></span>
00393 <span class="comment">RESUME: Recupere la valeur du parametre, lue sur la ligne de commande</span>
00394 <span class="comment"></span>
00395 <span class="comment">DESCRIPTION: Recupere la valeur du parametre demande, qui doit etre</span>
00396 <span class="comment">        lu sur la ligne de commande.</span>
00397 <span class="comment"></span>
00398 <span class="comment">SYNTAXE:     char *valeurParam = IdArgValue(char *label);</span>
00399 <span class="comment"></span>
00400 <span class="comment">RETOUR:      type  : char *</span>
00401 <span class="comment">        role  : Valeur, sous forme de chaine de caractere, du</span>
00402 <span class="comment">           parametre dont le label est specifie.</span>
00403 <span class="comment">           La chaine pointee ne doit pas etre modifiee.</span>
00404 <span class="comment">           Elle doit, si necessaire, etre d'abord recopiee</span>
00405 <span class="comment">           dans une autre chaine de caractere.</span>
00406 <span class="comment">           Si le label n'est pas trouve, la fonction retourne</span>
00407 <span class="comment">           le pointeur NULL.</span>
00408 <span class="comment"></span>
00409 <span class="comment">PARAMETRES:</span>
00410 <span class="comment">        nom   : label</span>
00411 <span class="comment">        type  : char *</span>
00412 <span class="comment">        role  : Nom du label du parametre recherche.</span>
00413 <span class="comment"></span>
00414 <span class="comment">FICHIER:     arg.c</span>
00415 <span class="comment"></span>
00416 <span class="comment">EXEMPLE:</span>
00417 <span class="comment">        {</span>
00418 <span class="comment">          char * ficsource;</span>
00419 <span class="comment">          char * ficdestination;</span>
00420 <span class="comment">          int    fic_defaut = 0:</span>
00421 <span class="comment"></span>
00422 <span class="comment">          nomfic = IdArgValue("FILEIN");</span>
00423 <span class="comment"></span>
00424 <span class="comment">          if ( (ficdestination = IdArgValue("FILEOUT")==0 ){</span>
00425 <span class="comment">       ficdestination = IdStrCreateNewSuffix(ficsource,".out");</span>
00426 <span class="comment">       fic_defaut = 1;</span>
00427 <span class="comment">          }</span>
00428 <span class="comment"></span>
00429 <span class="comment"></span>
00430 <span class="comment">...</span>
00431 <span class="comment">          if (fic_defaut) free( ficdestination );</span>
00432 <span class="comment">        }</span>
00433 <span class="comment"></span>
00434 <span class="comment">******************************************************** END DESCRIPTION */</span>
00435 <span class="keywordtype">char</span> *
<a name="l00436"></a><a class="code" href="idarg_8h.html#a15">00436</a> <a class="code" href="idarg_8h.html#a15">IdArgValue</a> ( Param )
00437   char * Param;
00438 {
00439   <span class="keywordtype">int</span> Trouve ;
00440 
00441 <span class="keywordflow">if</span> ( (Trouve = <a class="code" href="idarg_8h.html#a14">IdArgDefined</a> ( Param )) != <a class="code" href="idarg_8h.html#a3">FALSE</a> )
00442     <span class="keywordflow">return</span> ArgStr[Trouve] ;
00443   <span class="keywordflow">else</span> { <span class="keywordflow">return</span> NULL ;}
00444 }
00445 
00446 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00447 <span class="comment"></span>
00448 <span class="comment">IdArgUnused   (fonction)</span>
00449 <span class="comment"></span>
00450 <span class="comment">RESUME: Recherche du premier label encore non utilise.</span>
00451 <span class="comment"></span>
00452 <span class="comment">DESCRIPTION: Recherche du premier label non encore utilise.</span>
00453 <span class="comment">        Ce label devient alors un label utilise.</span>
00454 <span class="comment">        Si tous les labels sont deja utilises, retourne NULL.</span>
00455 <span class="comment"></span>
00456 <span class="comment">SYNTAXE:     char *label = IdArgUnused();</span>
00457 <span class="comment"></span>
00458 <span class="comment">RETOUR:      type  : char *</span>
00459 <span class="comment">        role  : Pointeur vers une chaine de caratere contenant</span>
00460 <span class="comment">           le premier label non utilise.</span>
00461 <span class="comment">           retourne NULL si tous les labels ont ete utilises.</span>
00462 <span class="comment"></span>
00463 <span class="comment">FICHIER:     arg.c</span>
00464 <span class="comment"></span>
00465 <span class="comment">EXEMPLE:     la fonction suivante permetrait d'imprimer tous les labels</span>
00466 <span class="comment">        de la chaine d'appel.</span>
00467 <span class="comment"></span>
00468 <span class="comment">        int imprime_labels ()</span>
00469 <span class="comment">        {</span>
00470 <span class="comment">          char * label;</span>
00471 <span class="comment">          int i=0;</span>
00472 <span class="comment">          while ( (label=IdArgUnused())!=0 )</span>
00473 <span class="comment">       IdPrintf ("Label %3d : %s   :  %s",</span>
00474 <span class="comment">            ++i,  label,  IdArgValue(label));</span>
00475 <span class="comment">          return i;</span>
00476 <span class="comment">        }</span>
00477 <span class="comment"></span>
00478 <span class="comment">******************************************************** END DESCRIPTION */</span>
00479 <span class="keywordtype">char</span> *
<a name="l00480"></a><a class="code" href="idarg_8h.html#a16">00480</a> <a class="code" href="arg_8c.html#a18">IdArgUnused</a> ( )
00481 {
00482   <span class="keywordtype">int</span> i ;
00483   <span class="keywordflow">for</span> ( i=ArgCount-1; i&gt;0; i-- ){                               <span class="comment">/* V1.04 */</span>
00484     <span class="keywordflow">if</span> ( ! ArgUsed[i] ) {
00485       <a class="code" href="idarg_8h.html#a14">IdArgDefined</a>(ArgLab[i]);                                  <span class="comment">/* V1.04 */</span>
00486       <span class="keywordflow">return</span> ArgLab[i] ;
00487     }
00488   }
00489   <span class="keywordflow">return</span> NULL ;
00490 }
00491 
00492 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00493 <span class="comment"></span>
00494 <span class="comment">IdArgPrintUnusedLabels   (fonction)</span>
00495 <span class="comment"></span>
00496 <span class="comment">RESUME: Imprime la liste des labels non utilises.</span>
00497 <span class="comment"></span>
00498 <span class="comment">DESCRIPTION: Imprime la liste des labels non  utilises.</span>
00499 <span class="comment"></span>
00500 <span class="comment">SYNTAXE:     int nbLabel = IdArgPrintUnusedLabels();</span>
00501 <span class="comment"></span>
00502 <span class="comment">RETOUR:      type  : int</span>
00503 <span class="comment">        role  : nombre de labels non utilises.</span>
00504 <span class="comment"></span>
00505 <span class="comment">FICHIER:     arg.c</span>
00506 <span class="comment"></span>
00507 <span class="comment">EXEMPLE:    </span>
00508 <span class="comment"></span>
00509 <span class="comment">******************************************************** END DESCRIPTION */</span>
<a name="l00510"></a><a class="code" href="idarg_8h.html#a19">00510</a> <span class="keywordtype">int</span> <a class="code" href="arg_8c.html#a19">IdArgPrintUnusedLabels</a> ()
00511 {
00512 <span class="keywordtype">char</span> * label;
00513 <span class="keywordtype">int</span> i=0;
00514 <span class="keywordflow">while</span> ( (label=<a class="code" href="arg_8c.html#a18">IdArgUnused</a>())!=0 )
00515    {       <span class="keywordflow">if</span> (i==0) <a class="code" href="kerprint_8c.html#a4">IdPrintf</a> (<span class="stringliteral">"\nLabels Inutilises\n================\n"</span>);
00516       <a class="code" href="kerprint_8c.html#a4">IdPrintf</a> (<span class="stringliteral">"Label : %s = %s\n"</span>, label,  <a class="code" href="idarg_8h.html#a15">IdArgValue</a>(label));
00517       i++;
00518    }
00519  <span class="keywordflow">return</span> i;
00520 }
00521 
00522 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00523 <span class="comment">* </span>
00524 <span class="comment">* IdArgUsage   (fonction)</span>
00525 <span class="comment">* </span>
00526 <span class="comment">* RESUME: Imprime le mode d'emploi d'un programme, et termine l'exec</span>
00527 <span class="comment">* </span>
00528 <span class="comment">* DESCRIPTION: Imprime le mode d'emploi d'un programme, et termine</span>
00529 <span class="comment">*       l'execution, en appelant la fonction IdExit().</span>
00530 <span class="comment">*       IdArgUsage peut s'utiliser avec START_USAGE et</span>
00531 <span class="comment">*       FINISH_USAGE (cf.exemple).</span>
00532 <span class="comment">* </span>
00533 <span class="comment">* SYNTAXE:     int retCode =IdArgUsage(char **usage)</span>
00534 <span class="comment">* </span>
00535 <span class="comment">* RETOUR:      type  : int (cf. role)</span>
00536 <span class="comment">*       role  : permettre l'utilisation de IdArgUsage() dans le</span>
00537 <span class="comment">*          corps meme d'une expression typee:</span>
00538 <span class="comment">*          Exemple : (a=IdArgValue()?1:IdArgusage(usage))</span>
00539 <span class="comment">* </span>
00540 <span class="comment">* PARAMETRES:</span>
00541 <span class="comment">*       nom   : usage</span>
00542 <span class="comment">*       type  : char **</span>
00543 <span class="comment">*       role  : tableau de pointeur vers les lignes de la</span>
00544 <span class="comment">*          documentation du filtre. La definition de usage</span>
00545 <span class="comment">*          est facilitee par les macro-commandes predefinies</span>
00546 <span class="comment">*          dans idarg.h : START_USAGE() et FINISH_USAGE.</span>
00547 <span class="comment">*          (cf.exemple)</span>
00548 <span class="comment">* </span>
00549 <span class="comment">* FICHIER:     arg.c</span>
00550 <span class="comment">* </span>
00551 <span class="comment">* EXEMPLE:</span>
00552 <span class="comment">*       #include &lt;idarg.h&gt;</span>
00553 <span class="comment">* </span>
00554 <span class="comment">*       START_USAGE(usage)                //usage : variable static </span>
00555 <span class="comment">*         "usage : &lt;nom&gt; ...",</span>
00556 <span class="comment">*         "\007",                           // erreur = bip(\007) ! </span>
00557 <span class="comment">*         "affiche cette aide :",</span>
00558 <span class="comment">*         "    programme exemple",</span>
00559 <span class="comment">*       FINISH_USAGE                     // fin definition 'usage'  </span>
00560 <span class="comment">* </span>
00561 <span class="comment">*       int main()</span>
00562 <span class="comment">*       {</span>
00563 <span class="comment">*         IdArgUsage(usage);                      // affiche la doc </span>
00564 <span class="comment">*       }</span>
00565 <span class="comment">* </span>
00566 <span class="comment">******************************************************** END DESCRIPTION */</span>
<a name="l00567"></a><a class="code" href="idarg_8h.html#a18">00567</a> <span class="keywordtype">int</span> <a class="code" href="idarg_8h.html#a18">IdArgUsage</a>(<span class="keywordtype">char</span> ** usage_text )
00568 {
00569   <span class="keywordflow">while</span> ( *usage_text ) 
00570     <a class="code" href="kerprint_8c.html#a4">IdPrintf</a>(<span class="stringliteral">"\n%s"</span>, *(usage_text++) );
00571   <a class="code" href="kerprint_8c.html#a4">IdPrintf</a> ( <span class="stringliteral">"\n"</span> ) ; 
00572   <a class="code" href="iderr_8h.html#a66">IdExit</a> (1);
00573   <span class="keywordflow">return</span> (0);
00574 }
00575 
00576 <span class="comment">// liberation de la memoire utilisee par ArgInit </span>
<a name="l00577"></a><a class="code" href="idarg_8h.html#a36">00577</a> <span class="keywordtype">int</span> <a class="code" href="arg_8c.html#a21">_IdArgFree</a>()
00578 {
00579   <span class="keywordtype">int</span> i;
00580 
00581   <span class="keywordflow">for</span>(i=0;i&lt;ArgCount;i++)
00582     <span class="keywordflow">if</span>(ArgLab[i])free(ArgLab[i]);
00583   <span class="keywordflow">if</span>(ArgUsed)free(ArgUsed);
00584   <span class="keywordflow">if</span>(Appel)free(Appel);
00585   <span class="keywordflow">return</span> 0;
00586 }
00587 
00588 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00589 <span class="comment"></span>
00590 <span class="comment">IdArgSave    (fonction)</span>
00591 <span class="comment"></span>
00592 <span class="comment">RESUME: sauvegarde une chaine de caract. dans un fichier de parametres</span>
00593 <span class="comment"></span>
00594 <span class="comment">DESCRIPTION: sauvegarde une chaine de caractere dans un fichier de</span>
00595 <span class="comment">        parametres. Le nom du fichier est celui specifie sur la ligne</span>
00596 <span class="comment">        d'appel par : PARAMOUT=???</span>
00597 <span class="comment">        ou, par defaut, celui donne par ARG_DEFAULT_PARAMOUT</span>
00598 <span class="comment">        (chaine de caractere definie dans idarg.h).</span>
00599 <span class="comment"></span>
00600 <span class="comment">SYNTAXE:     int retCode = IdArgSave ( char *parametre );</span>
00601 <span class="comment"></span>
00602 <span class="comment">RETOUR:      type  : int</span>
00603 <span class="comment">        role  : 0 : echec ; !=0 succes.</span>
00604 <span class="comment">           En cas d'echec, IdErrno vaut l'un des valeurs</span>
00605 <span class="comment">           suivantes :</span>
00606 <span class="comment">             IDERR_POINTER_IS_NULL : Pointeur NULL (parametre)</span>
00607 <span class="comment">             IDERR_OPEN_FAILED     : Echec ouverture fichier</span>
00608 <span class="comment"></span>
00609 <span class="comment">PARAMETRES:</span>
00610 <span class="comment">        nom   : parametre</span>
00611 <span class="comment">        type  : char *</span>
00612 <span class="comment">        role  : Chaine de caractere definissant le parametre:</span>
00613 <span class="comment">             "label=valeur"</span>
00614 <span class="comment"></span>
00615 <span class="comment">FICHIER:     arg.c</span>
00616 <span class="comment"></span>
00617 <span class="comment">EXEMPLE:</span>
00618 <span class="comment">        IdErrno = 0;</span>
00619 <span class="comment">        IdArgSave("FILEIN=lena128.img");</span>
00620 <span class="comment">        IdArgSave("DIM=128");</span>
00621 <span class="comment">        IdArgSave("LOG=mylog.log");</span>
00622 <span class="comment">        if (IdErrno) IdErrPrintf ("\nEchec de sauvegarde de parametres");</span>
00623 <span class="comment"></span>
00624 <span class="comment">******************************************************** END DESCRIPTION */</span>
00625 <span class="comment">/*------------------------------------------------------------------------</span>
00626 <span class="comment"> | Role       : Sauvegarde dans un fichier de parametres de sortie</span>
00627 <span class="comment"> | Retour     : Type   : int</span>
00628 <span class="comment"> |              Role   : Indicateur d'erreur: 1 = OK,  0 = AIE AIE AIE</span>
00629 <span class="comment"> | Parametres : param  : char *</span>
00630 <span class="comment"> |              Role   : pointeur vers la chaine a sauvegarder</span>
00631 <span class="comment"> |</span>
00632 <span class="comment"> +------------------------------------------------------------------------*/</span>
00633 <span class="keywordtype">int</span>
<a name="l00634"></a><a class="code" href="idarg_8h.html#a17">00634</a> <a class="code" href="idarg_8h.html#a17">IdArgSave</a> ( param )
00635   char * param;
00636 {
00637   <span class="keyword">static</span> <span class="keywordtype">int</span>   deja = 0;
00638   FILE         * fd;
00639 
00640   <span class="keywordflow">if</span> ( *ArgParamOut == <span class="charliteral">'\0'</span> ) {
00641     <span class="keywordflow">return</span> 0;
00642   }
00643   <span class="keywordflow">if</span>(deja) {
00644     fd = fopen ( ArgParamOut, <span class="stringliteral">"a+"</span> );
00645   }<span class="keywordflow">else</span>{
00646     deja = 1;
00647     fd = fopen ( ArgParamOut, <span class="stringliteral">"w"</span> );
00648   }
00649 
00650   <span class="keywordflow">if</span> ( !fd ) <span class="keywordflow">return</span> 0;
00651 
00652   fprintf ( fd, <span class="stringliteral">"%s\n"</span>, param );
00653   fclose  ( fd );
00654   <span class="keywordflow">return</span> 1;
00655 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 20 14:28:13 2006 for SIMRI3D by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
