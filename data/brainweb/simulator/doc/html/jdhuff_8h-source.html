<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SIMRI3D: jdhuff.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>jdhuff.h</h1><a href="jdhuff_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*</span>
00002 <span class="comment"> * jdhuff.h</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright (C) 1991-1997, Thomas G. Lane.</span>
00005 <span class="comment"> * This file is part of the Independent JPEG Group's software.</span>
00006 <span class="comment"> * For conditions of distribution and use, see the accompanying README file.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * This file contains declarations for Huffman entropy decoding routines</span>
00009 <span class="comment"> * that are shared between the sequential decoder (jdhuff.c) and the</span>
00010 <span class="comment"> * progressive decoder (jdphuff.c).  No other modules need to see these.</span>
00011 <span class="comment"> */</span>
00012 
00013 <span class="comment">/* Short forms of external names for systems with brain-damaged linkers. */</span>
00014 
00015 <span class="preprocessor">#ifdef NEED_SHORT_EXTERNAL_NAMES</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#define jpeg_make_d_derived_tbl  jMkDDerived</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#define jpeg_fill_bit_buffer  jFilBitBuf</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#define jpeg_huff_decode   jHufDecode</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* NEED_SHORT_EXTERNAL_NAMES */</span>
00020 
00021 
00022 <span class="comment">/* Derived data constructed for each Huffman table */</span>
00023 
<a name="l00024"></a><a class="code" href="jdhuff_8h.html#a0">00024</a> <span class="preprocessor">#define HUFF_LOOKAHEAD  8  </span><span class="comment">/* # of bits of lookahead */</span>
00025 
<a name="l00026"></a><a class="code" href="structd__derived__tbl.html">00026</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00027   <span class="comment">/* Basic tables: (element [0] of each array is unused) */</span>
<a name="l00028"></a><a class="code" href="structd__derived__tbl.html#o0">00028</a>   <a class="code" href="jmorecfg_8h.html#a21">INT32</a> maxcode[18];    <span class="comment">/* largest code of length k (-1 if none) */</span>
00029   <span class="comment">/* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */</span>
<a name="l00030"></a><a class="code" href="structd__derived__tbl.html#o1">00030</a>   <a class="code" href="jmorecfg_8h.html#a21">INT32</a> valoffset[17];     <span class="comment">/* huffval[] offset for codes of length k */</span>
00031   <span class="comment">/* valoffset[k] = huffval[] index of 1st symbol of code length k, less</span>
00032 <span class="comment">   * the smallest code of length k; so given a code of length k, the</span>
00033 <span class="comment">   * corresponding symbol is huffval[code + valoffset[k]]</span>
00034 <span class="comment">   */</span>
00035 
00036   <span class="comment">/* Link to public Huffman table (needed only in jpeg_huff_decode) */</span>
<a name="l00037"></a><a class="code" href="structd__derived__tbl.html#o2">00037</a>   <a class="code" href="structJHUFF__TBL.html">JHUFF_TBL</a> *pub;
00038 
00039   <span class="comment">/* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of</span>
00040 <span class="comment">   * the input data stream.  If the next Huffman code is no more</span>
00041 <span class="comment">   * than HUFF_LOOKAHEAD bits long, we can obtain its length and</span>
00042 <span class="comment">   * the corresponding symbol directly from these tables.</span>
00043 <span class="comment">   */</span>
<a name="l00044"></a><a class="code" href="structd__derived__tbl.html#o3">00044</a>   <span class="keywordtype">int</span> look_nbits[1&lt;&lt;<a class="code" href="jdhuff_8h.html#a0">HUFF_LOOKAHEAD</a>]; <span class="comment">/* # bits, or 0 if too long */</span>
<a name="l00045"></a><a class="code" href="structd__derived__tbl.html#o4">00045</a>   <a class="code" href="jmorecfg_8h.html#a18">UINT8</a> look_sym[1&lt;&lt;<a class="code" href="jdhuff_8h.html#a0">HUFF_LOOKAHEAD</a>]; <span class="comment">/* symbol, or unused */</span>
00046 } <a class="code" href="structd__derived__tbl.html">d_derived_tbl</a>;
00047 
00048 <span class="comment">/* Expand a Huffman table definition into the derived format */</span>
00049 <a class="code" href="jmorecfg_8h.html#a10">EXTERN</a>(<span class="keywordtype">void</span>) jpeg_make_d_derived_tbl
<a name="l00050"></a><a class="code" href="jdhuff_8h.html#a11">00050</a>    JPP((<a class="code" href="structjpeg__decompress__struct.html">j_decompress_ptr</a> cinfo, <span class="keywordtype">boolean</span> isDC, <span class="keywordtype">int</span> tblno,
00051         <a class="code" href="structd__derived__tbl.html">d_derived_tbl</a> ** pdtbl));
00052 
00053 
00054 <span class="comment">/*</span>
00055 <span class="comment"> * Fetching the next N bits from the input stream is a time-critical operation</span>
00056 <span class="comment"> * for the Huffman decoders.  We implement it with a combination of inline</span>
00057 <span class="comment"> * macros and out-of-line subroutines.  Note that N (the number of bits</span>
00058 <span class="comment"> * demanded at one time) never exceeds 15 for JPEG use.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * We read source bytes into get_buffer and dole out bits as needed.</span>
00061 <span class="comment"> * If get_buffer already contains enough bits, they are fetched in-line</span>
00062 <span class="comment"> * by the macros CHECK_BIT_BUFFER and GET_BITS.  When there aren't enough</span>
00063 <span class="comment"> * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer</span>
00064 <span class="comment"> * as full as possible (not just to the number of bits needed; this</span>
00065 <span class="comment"> * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).</span>
00066 <span class="comment"> * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.</span>
00067 <span class="comment"> * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains</span>
00068 <span class="comment"> * at least the requested number of bits --- dummy zeroes are inserted if</span>
00069 <span class="comment"> * necessary.</span>
00070 <span class="comment"> */</span>
00071 
<a name="l00072"></a><a class="code" href="jdhuff_8h.html#a13">00072</a> typedef INT32 <a class="code" href="jdhuff_8h.html#a13">bit_buf_type</a>;   <span class="comment">/* type of bit-extraction buffer */</span>
<a name="l00073"></a><a class="code" href="jdhuff_8h.html#a1">00073</a> #define BIT_BUF_SIZE  32   <span class="comment">/* size of buffer in bits */</span>
00074 
00075 <span class="comment">/* If long is &gt; 32 bits on your machine, and shifting/masking longs is</span>
00076 <span class="comment"> * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE</span>
00077 <span class="comment"> * appropriately should be a win.  Unfortunately we can't define the size</span>
00078 <span class="comment"> * with something like  #define BIT_BUF_SIZE (sizeof(bit_buf_type)*8)</span>
00079 <span class="comment"> * because not all machines measure sizeof in 8-bit bytes.</span>
00080 <span class="comment"> */</span>
00081 
<a name="l00082"></a><a class="code" href="structbitread__perm__state.html">00082</a> typedef struct {     <span class="comment">/* Bitreading state saved across MCUs */</span>
<a name="l00083"></a><a class="code" href="structbitread__perm__state.html#o0">00083</a>   <a class="code" href="jdhuff_8h.html#a13">bit_buf_type</a> <a class="code" href="jdhuff_8h.html#a14">get_buffer</a>; <span class="comment">/* current bit-extraction buffer */</span>
<a name="l00084"></a><a class="code" href="structbitread__perm__state.html#o1">00084</a>   <span class="keywordtype">int</span> <a class="code" href="jdhuff_8h.html#a15">bits_left</a>;     <span class="comment">/* # of unused bits in it */</span>
00085 } <a class="code" href="structbitread__perm__state.html">bitread_perm_state</a>;
00086 
<a name="l00087"></a><a class="code" href="structbitread__working__state.html">00087</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{     <span class="comment">/* Bitreading working state within an MCU */</span>
00088   <span class="comment">/* Current data source location */</span>
00089   <span class="comment">/* We need a copy, rather than munging the original, in case of suspension */</span>
<a name="l00090"></a><a class="code" href="structbitread__working__state.html#o0">00090</a>   <span class="keyword">const</span> <a class="code" href="jmorecfg_8h.html#a17">JOCTET</a> * next_input_byte; <span class="comment">/* =&gt; next byte to read from source */</span>
<a name="l00091"></a><a class="code" href="structbitread__working__state.html#o1">00091</a>   size_t bytes_in_buffer;  <span class="comment">/* # of bytes remaining in source buffer */</span>
00092   <span class="comment">/* Bit input buffer --- note these values are kept in register variables,</span>
00093 <span class="comment">   * not in this struct, inside the inner loops.</span>
00094 <span class="comment">   */</span>
<a name="l00095"></a><a class="code" href="structbitread__working__state.html#o2">00095</a>   <a class="code" href="jdhuff_8h.html#a13">bit_buf_type</a> <a class="code" href="jdhuff_8h.html#a14">get_buffer</a>; <span class="comment">/* current bit-extraction buffer */</span>
<a name="l00096"></a><a class="code" href="structbitread__working__state.html#o3">00096</a>   <span class="keywordtype">int</span> <a class="code" href="jdhuff_8h.html#a15">bits_left</a>;     <span class="comment">/* # of unused bits in it */</span>
00097   <span class="comment">/* Pointer needed by jpeg_fill_bit_buffer. */</span>
<a name="l00098"></a><a class="code" href="structbitread__working__state.html#o4">00098</a>   <a class="code" href="structjpeg__decompress__struct.html">j_decompress_ptr</a> cinfo;  <span class="comment">/* back link to decompress master record */</span>
00099 } <a class="code" href="structbitread__working__state.html">bitread_working_state</a>;
00100 
00101 <span class="comment">/* Macros to declare and load/save bitread local variables. */</span>
<a name="l00102"></a><a class="code" href="jdhuff_8h.html#a2">00102</a> <span class="preprocessor">#define BITREAD_STATE_VARS  \</span>
00103 <span class="preprocessor">   register bit_buf_type get_buffer;  \</span>
00104 <span class="preprocessor">   register int bits_left;  \</span>
00105 <span class="preprocessor">   bitread_working_state br_state</span>
00106 <span class="preprocessor"></span>
<a name="l00107"></a><a class="code" href="jdhuff_8h.html#a3">00107</a> <span class="preprocessor">#define BITREAD_LOAD_STATE(cinfop,permstate)  \</span>
00108 <span class="preprocessor">   br_state.cinfo = cinfop; \</span>
00109 <span class="preprocessor">   br_state.next_input_byte = cinfop-&gt;src-&gt;next_input_byte; \</span>
00110 <span class="preprocessor">   br_state.bytes_in_buffer = cinfop-&gt;src-&gt;bytes_in_buffer; \</span>
00111 <span class="preprocessor">   get_buffer = permstate.get_buffer; \</span>
00112 <span class="preprocessor">   bits_left = permstate.bits_left;</span>
00113 <span class="preprocessor"></span>
<a name="l00114"></a><a class="code" href="jdhuff_8h.html#a4">00114</a> <span class="preprocessor">#define BITREAD_SAVE_STATE(cinfop,permstate)  \</span>
00115 <span class="preprocessor">   cinfop-&gt;src-&gt;next_input_byte = br_state.next_input_byte; \</span>
00116 <span class="preprocessor">   cinfop-&gt;src-&gt;bytes_in_buffer = br_state.bytes_in_buffer; \</span>
00117 <span class="preprocessor">   permstate.get_buffer = get_buffer; \</span>
00118 <span class="preprocessor">   permstate.bits_left = bits_left</span>
00119 <span class="preprocessor"></span>
00120 <span class="comment">/*</span>
00121 <span class="comment"> * These macros provide the in-line portion of bit fetching.</span>
00122 <span class="comment"> * Use CHECK_BIT_BUFFER to ensure there are N bits in get_buffer</span>
00123 <span class="comment"> * before using GET_BITS, PEEK_BITS, or DROP_BITS.</span>
00124 <span class="comment"> * The variables get_buffer and bits_left are assumed to be locals,</span>
00125 <span class="comment"> * but the state struct might not be (jpeg_huff_decode needs this).</span>
00126 <span class="comment"> * CHECK_BIT_BUFFER(state,n,action);</span>
00127 <span class="comment"> *    Ensure there are N bits in get_buffer; if suspend, take action.</span>
00128 <span class="comment"> *      val = GET_BITS(n);</span>
00129 <span class="comment"> *    Fetch next N bits.</span>
00130 <span class="comment"> *      val = PEEK_BITS(n);</span>
00131 <span class="comment"> *    Fetch next N bits without removing them from the buffer.</span>
00132 <span class="comment"> * DROP_BITS(n);</span>
00133 <span class="comment"> *    Discard next N bits.</span>
00134 <span class="comment"> * The value N should be a simple variable, not an expression, because it</span>
00135 <span class="comment"> * is evaluated multiple times.</span>
00136 <span class="comment"> */</span>
00137 
<a name="l00138"></a><a class="code" href="jdhuff_8h.html#a5">00138</a> <span class="preprocessor">#define CHECK_BIT_BUFFER(state,nbits,action) \</span>
00139 <span class="preprocessor">   { if (bits_left &lt; (nbits)) {  \</span>
00140 <span class="preprocessor">       if (! jpeg_fill_bit_buffer(&amp;(state),get_buffer,bits_left,nbits))  \</span>
00141 <span class="preprocessor">         { action; }  \</span>
00142 <span class="preprocessor">       get_buffer = (state).get_buffer; bits_left = (state).bits_left; } }</span>
00143 <span class="preprocessor"></span>
<a name="l00144"></a><a class="code" href="jdhuff_8h.html#a6">00144</a> <span class="preprocessor">#define GET_BITS(nbits) \</span>
00145 <span class="preprocessor">   (((int) (get_buffer &gt;&gt; (bits_left -= (nbits)))) &amp; ((1&lt;&lt;(nbits))-1))</span>
00146 <span class="preprocessor"></span>
<a name="l00147"></a><a class="code" href="jdhuff_8h.html#a7">00147</a> <span class="preprocessor">#define PEEK_BITS(nbits) \</span>
00148 <span class="preprocessor">   (((int) (get_buffer &gt;&gt; (bits_left -  (nbits)))) &amp; ((1&lt;&lt;(nbits))-1))</span>
00149 <span class="preprocessor"></span>
<a name="l00150"></a><a class="code" href="jdhuff_8h.html#a8">00150</a> <span class="preprocessor">#define DROP_BITS(nbits) \</span>
00151 <span class="preprocessor">   (bits_left -= (nbits))</span>
00152 <span class="preprocessor"></span>
00153 <span class="comment">/* Load up the bit buffer to a depth of at least nbits */</span>
00154 <a class="code" href="jmorecfg_8h.html#a10">EXTERN</a>(<span class="keywordtype">boolean</span>) jpeg_fill_bit_buffer
<a name="l00155"></a><a class="code" href="jdhuff_8h.html#a16">00155</a>    JPP((<a class="code" href="structbitread__working__state.html">bitread_working_state</a> * state, register bit_buf_type get_buffer,
00156         register <span class="keywordtype">int</span> bits_left, <span class="keywordtype">int</span> nbits));
00157 
00158 
00159 <span class="comment">/*</span>
00160 <span class="comment"> * Code for extracting next Huffman-coded symbol from input bit stream.</span>
00161 <span class="comment"> * Again, this is time-critical and we make the main paths be macros.</span>
00162 <span class="comment"> *</span>
00163 <span class="comment"> * We use a lookahead table to process codes of up to HUFF_LOOKAHEAD bits</span>
00164 <span class="comment"> * without looping.  Usually, more than 95% of the Huffman codes will be 8</span>
00165 <span class="comment"> * or fewer bits long.  The few overlength codes are handled with a loop,</span>
00166 <span class="comment"> * which need not be inline code.</span>
00167 <span class="comment"> *</span>
00168 <span class="comment"> * Notes about the HUFF_DECODE macro:</span>
00169 <span class="comment"> * 1. Near the end of the data segment, we may fail to get enough bits</span>
00170 <span class="comment"> *    for a lookahead.  In that case, we do it the hard way.</span>
00171 <span class="comment"> * 2. If the lookahead table contains no entry, the next code must be</span>
00172 <span class="comment"> *    more than HUFF_LOOKAHEAD bits long.</span>
00173 <span class="comment"> * 3. jpeg_huff_decode returns -1 if forced to suspend.</span>
00174 <span class="comment"> */</span>
00175 
<a name="l00176"></a><a class="code" href="jdhuff_8h.html#a9">00176</a> #define HUFF_DECODE(result,state,htbl,failaction,slowlabel) \
00177 { <span class="keyword">register</span> <span class="keywordtype">int</span> nb, look; \
00178   <span class="keywordflow">if</span> (<a class="code" href="jdhuff_8h.html#a15">bits_left</a> &lt; <a class="code" href="jdhuff_8h.html#a0">HUFF_LOOKAHEAD</a>) { \
00179     <span class="keywordflow">if</span> (! jpeg_fill_bit_buffer(&amp;state,<a class="code" href="jdhuff_8h.html#a14">get_buffer</a>,<a class="code" href="jdhuff_8h.html#a15">bits_left</a>, 0)) {failaction;} \
00180     <a class="code" href="jdhuff_8h.html#a14">get_buffer</a> = state.get_buffer; <a class="code" href="jdhuff_8h.html#a15">bits_left</a> = state.bits_left; \
00181     <span class="keywordflow">if</span> (<a class="code" href="jdhuff_8h.html#a15">bits_left</a> &lt; <a class="code" href="jdhuff_8h.html#a0">HUFF_LOOKAHEAD</a>) { \
00182       nb = 1; <span class="keywordflow">goto</span> slowlabel; \
00183     } \
00184   } \
00185   look = <a class="code" href="jdhuff_8h.html#a7">PEEK_BITS</a>(<a class="code" href="jdhuff_8h.html#a0">HUFF_LOOKAHEAD</a>); \
00186   <span class="keywordflow">if</span> ((nb = <a class="code" href="jdhuff_8h.html#a17">htbl</a>-&gt;<a class="code" href="structd__derived__tbl.html#o3">look_nbits</a>[look]) != 0) { \
00187     <a class="code" href="jdhuff_8h.html#a8">DROP_BITS</a>(nb); \
00188     result = <a class="code" href="jdhuff_8h.html#a17">htbl</a>-&gt;<a class="code" href="structd__derived__tbl.html#o4">look_sym</a>[look]; \
00189   } <span class="keywordflow">else</span> { \
00190     nb = <a class="code" href="jdhuff_8h.html#a0">HUFF_LOOKAHEAD</a>+1; \
00191 slowlabel: \
00192     <span class="keywordflow">if</span> ((result=jpeg_huff_decode(&amp;state,<a class="code" href="jdhuff_8h.html#a14">get_buffer</a>,<a class="code" href="jdhuff_8h.html#a15">bits_left</a>,<a class="code" href="jdhuff_8h.html#a17">htbl</a>,nb)) &lt; 0) \
00193    { failaction; } \
00194     <a class="code" href="jdhuff_8h.html#a14">get_buffer</a> = state.get_buffer; <a class="code" href="jdhuff_8h.html#a15">bits_left</a> = state.bits_left; \
00195   } \
00196 }
00197 
00198 <span class="comment">/* Out-of-line case for Huffman code fetching */</span>
00199 <a class="code" href="jmorecfg_8h.html#a10">EXTERN</a>(<span class="keywordtype">int</span>) jpeg_huff_decode
<a name="l00200"></a><a class="code" href="jdhuff_8h.html#a18">00200</a>    JPP((<a class="code" href="structbitread__working__state.html">bitread_working_state</a> * state, register bit_buf_type get_buffer,
00201         register <span class="keywordtype">int</span> bits_left, <a class="code" href="structd__derived__tbl.html">d_derived_tbl</a> * htbl, <span class="keywordtype">int</span> min_bits));
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 20 14:28:14 2006 for SIMRI3D by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
