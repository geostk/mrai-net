<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SIMRI3D: str.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>str.c</h1><a href="str_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*************************************************************************</span>
00002 <span class="comment">* $Id: str.c,v 1.1 2005/09/09 08:22:55 bellet Exp $</span>
00003 <span class="comment">**************************************************************************</span>
00004 <span class="comment"> This software is governed by the CeCILL  license under French law and</span>
00005 <span class="comment">  abiding by the rules of distribution of free software.  You can  use, </span>
00006 <span class="comment">  modify and/ or redistribute the software under the terms of the CeCILL</span>
00007 <span class="comment">  license as circulated by CEA, CNRS and INRIA at the following URL</span>
00008 <span class="comment">  "http://www.cecill.info". </span>
00009 <span class="comment">  </span>
00010 <span class="comment">  As a counterpart to the access to the source code and  rights to copy,</span>
00011 <span class="comment">  modify and redistribute granted by the license, users are provided only</span>
00012 <span class="comment">  with a limited warranty  and the software's author,  the holder of the</span>
00013 <span class="comment">  economic rights,  and the successive licensors  have only  limited</span>
00014 <span class="comment">  liability. </span>
00015 <span class="comment">  </span>
00016 <span class="comment">  In this respect, the user's attention is drawn to the risks associated</span>
00017 <span class="comment">  with loading,  using,  modifying and/or developing or reproducing the</span>
00018 <span class="comment">  software by the user in light of its specific status of free software,</span>
00019 <span class="comment">  that may mean  that it is complicated to manipulate,  and  that  also</span>
00020 <span class="comment">  therefore means  that it is reserved for developers  and  experienced</span>
00021 <span class="comment">  professionals having in-depth computer knowledge. Users are therefore</span>
00022 <span class="comment">  encouraged to load and test the software's suitability as regards their</span>
00023 <span class="comment">  requirements in conditions enabling the security of their systems and/or </span>
00024 <span class="comment">  data to be ensured and,  more generally, to use and operate it in the </span>
00025 <span class="comment">  same conditions as regards security. </span>
00026 <span class="comment">  </span>
00027 <span class="comment">  The fact that you are presently reading this means that you have had</span>
00028 <span class="comment">  knowledge of the CeCILL license and that you accept its terms.</span>
00029 <span class="comment">  </span>
00030 <span class="comment">  Copyright (c) CREATIS (Centre de Recherche et d'Applications en Traitement de</span>
00031 <span class="comment">  l'Image). All rights reserved. See License.txt for details.</span>
00032 <span class="comment">  </span>
00033 <span class="comment">  Version 1.0  05/09/2005</span>
00034 <span class="comment">*************************************************************************/</span>
00035 
00036 <span class="comment">/*************************************************************************</span>
00037 <span class="comment">*</span>
00038 <span class="comment">*  Description  : Divers utilitaires Chaine de caract.</span>
00039 <span class="comment">*</span>
00040 <span class="comment">**************************************************************************/</span>
00041 
00042 <span class="preprocessor">#include &lt;string.h&gt;</span>  <span class="comment">// For strtok, strstr, strlen</span>
00043 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>  <span class="comment">// For strtol and strtod</span>
00044 <span class="preprocessor">#include &lt;stdio.h&gt;</span>   <span class="comment">// For sprintf</span>
00045 <span class="preprocessor">#include &lt;ctype.h&gt;</span>   <span class="comment">// For toupper</span>
00046 
00047 <span class="preprocessor">#include "<a class="code" href="idstr_8h.html">idstr.h</a>"</span>
00048 <span class="preprocessor">#include "<a class="code" href="iderr_8h.html">iderr.h</a>"</span>
00049 <span class="comment">//#include "idprint.h"</span>
00050 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00051 <span class="preprocessor">#include "<a class="code" href="iddicom_8h.html">iddicom.h</a>"</span>
00052 
00053 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00054 <span class="comment">* </span>
00055 <span class="comment">* IdStrCreateNewSuffix (fonction)</span>
00056 <span class="comment">* </span>
00057 <span class="comment">* RESUME: change le suffixe d'un nom de fichier</span>
00058 <span class="comment">* </span>
00059 <span class="comment">* DESCRIPTION: Cree une chaine de caractere decrivant le nom d'un fichier</span>
00060 <span class="comment">*       a partir d'un nom existant, en changeant le suffixe.</span>
00061 <span class="comment">* </span>
00062 <span class="comment">* SYNTAXE:      char *newfilename = IdStrCreateNewSuffix (char * oldname, char * suffix);</span>
00063 <span class="comment">* </span>
00064 <span class="comment">* RETOUR:      type  : char *</span>
00065 <span class="comment">*       role  : pointeur vers la zone allouee contenant le nouveau</span>
00066 <span class="comment">*          nom de fichier.</span>
00067 <span class="comment">* </span>
00068 <span class="comment">* PARAMETRES:  nom   : oldname</span>
00069 <span class="comment">*       type  : char *</span>
00070 <span class="comment">*       role  : Nom du fichier 'modele'.</span>
00071 <span class="comment">* </span>
00072 <span class="comment">*       nom   : suffix</span>
00073 <span class="comment">*       type  : char *</span>
00074 <span class="comment">*       role  : Nom du suffixe qui sera mis a la place du suffixe</span>
00075 <span class="comment">*          precedent.</span>
00076 <span class="comment">* </span>
00077 <span class="comment">* FICHIER:     idstr.c</span>
00078 <span class="comment">* </span>
00079 <span class="comment">* EXEMPLES:    filename = IdStrCreateNewSuffix ("nom.txt",".lis");</span>
00080 <span class="comment">* </span>
00081 <span class="comment">*        =&gt; filename = "nom.lis"</span>
00082 <span class="comment">* </span>
00083 <span class="comment">*       filename = IdStrCreateNewSuffix ("nom.txt","00.lis");</span>
00084 <span class="comment">* </span>
00085 <span class="comment">*        =&gt; filename = "nom00.lis"</span>
00086 <span class="comment">* </span>
00087 <span class="comment">*    (sur vax) filename = IdStrCreateNewSuffix ("d$extern:[txt.dir]nom",".txt");</span>
00088 <span class="comment">* </span>
00089 <span class="comment">*        =&gt; filename = "d$extern:[txt.dir]nom.txt"</span>
00090 <span class="comment">* </span>
00091 <span class="comment">*    (sur unix)filename = IdStrCreateNewSuffix ("/usr/test.dir/nom.o.t",".txt");</span>
00092 <span class="comment">* </span>
00093 <span class="comment">*        =&gt; filename = "/usr/test.dir/nom.o.txt"</span>
00094 <span class="comment">* </span>
00095 <span class="comment">*    (sur dos) filename = IdStrCreateNewSuffix ("c:\ess.dir\nom",".text");</span>
00096 <span class="comment">* </span>
00097 <span class="comment">*        =&gt; filename = "c:\ess.dir\nom.text"</span>
00098 <span class="comment">* </span>
00099 <span class="comment">******************************************************** END DESCRIPTION */</span>
00100 
<a name="l00109"></a><a class="code" href="str_8c.html#a0">00109</a> <span class="keywordtype">char</span> * <a class="code" href="str_8c.html#a0">IdStrCreateNewSuffix</a> (<span class="keywordtype">char</span> * nom, <span class="keywordtype">char</span> * suffix )
00110 {
00111   <span class="keywordtype">char</span>        * fin;
00112   <span class="keywordtype">char</span>        * nouveau;
00113   <span class="keywordtype">char</span>        * ajout;
00114   <span class="keywordtype">int</span>           car_copie;
00115   <span class="keywordtype">int</span>           taille;
00116 
00117                  <span class="comment">/* fin pointe sur fin du nom **/</span>
00118   <span class="keywordflow">for</span> ( fin = nom; *fin != <span class="charliteral">'\0'</span>; fin ++ );
00119                                           <span class="comment">/* cherche 1 '.' avant la fin */</span>
00120   <span class="keywordflow">for</span> ( ajout = fin; (*ajout!=<span class="charliteral">'.'</span>); ajout -- ) {
00121                                           <span class="comment">/* Pas de '.' trouve **********/</span>
00122     <span class="keywordflow">if</span> ( ajout &lt;= nom ) {
00123       ajout = fin ;
00124       <span class="keywordflow">break</span>;
00125     }
00126                                           <span class="comment">/* carac. interdit trouve *****/</span>
00127     <span class="keywordflow">if</span> (
00128 
00129 <span class="preprocessor">#if defined(_MSC_VER)</span>
00130 <span class="preprocessor"></span>        (*ajout==<span class="charliteral">':'</span>)||(*ajout==<span class="charliteral">'\\'</span>)
00131 <span class="preprocessor">#else</span>
00132 <span class="preprocessor"></span>        (*ajout==<span class="charliteral">'/'</span>)
00133 <span class="preprocessor">#endif</span>
00134 <span class="preprocessor"></span>
00135     ) {
00136       ajout = fin ;
00137       <span class="keywordflow">break</span>;
00138     }
00139   }
00140                  <span class="comment">/* calcul taille finale *******/</span>
00141   taille = (<span class="keywordtype">int</span>) (ajout-nom) + 2 + strlen(suffix) ;
00142                  <span class="comment">/* et reservation memoire *****/</span>
00143   nouveau = (<span class="keywordtype">char</span> *)malloc (taille) ;
00144                  <span class="comment">/* copie du prefixe ***********/</span>
00145   <span class="keywordflow">for</span> ( car_copie = 0; nom &lt; ajout; car_copie ++ )
00146     nouveau[car_copie] = *(nom++);
00147                  <span class="comment">/* et ajout du suffixe ********/</span>
00148   <span class="keywordflow">for</span> ( ajout = suffix; car_copie &lt; taille; car_copie++ )
00149     nouveau[car_copie] = *(ajout++);
00150 
00151   <span class="keywordflow">return</span> nouveau;
00152 }
00153 
00154 
00155 
00156 
00157 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00158 <span class="comment"></span>
00159 <span class="comment">IdStrRemoveSuffix (fonction)</span>
00160 <span class="comment"></span>
00161 <span class="comment">RESUME: Supprime le suffixe d'un nom de fichier</span>
00162 <span class="comment"></span>
00163 <span class="comment">DESCRIPTION: Cree une chaine de caractere decrivant le nom d'un fichier</span>
00164 <span class="comment">        a partir d'un nom existant, en suprimant le suffixe.</span>
00165 <span class="comment"></span>
00166 <span class="comment">SYNTAXE:      char *newfilename = IdStrRemoveSuffix (char * oldname);</span>
00167 <span class="comment"></span>
00168 <span class="comment">RETOUR:      type  : char *</span>
00169 <span class="comment">        role  : pointeur vers la zone allouee contenant le nouveau</span>
00170 <span class="comment">           nom de fichier.</span>
00171 <span class="comment"></span>
00172 <span class="comment">PARAMETRES:  nom   : oldname</span>
00173 <span class="comment">        type  : char *</span>
00174 <span class="comment">        role  : Nom du fichier 'modele'.</span>
00175 <span class="comment"></span>
00176 <span class="comment">FICHIER:     idstr.c</span>
00177 <span class="comment"></span>
00178 <span class="comment">EXEMPLES:    filename = IdStrRemoveSuffix ("nom.txt");</span>
00179 <span class="comment"></span>
00180 <span class="comment">         =&gt; filename = "nom"</span>
00181 <span class="comment"></span>
00182 <span class="comment">        filename = IdStrRemoveSuffix ("/export/home/nom/test/nom.txt");</span>
00183 <span class="comment"></span>
00184 <span class="comment">         =&gt; filename = "/export/home/nom/test/nom"</span>
00185 <span class="comment"></span>
00186 <span class="comment">   (sur vax) filename = IdStrRemoveSuffix ("d$extern:[txt.dir]nom");</span>
00187 <span class="comment"></span>
00188 <span class="comment">         =&gt; filename = "d$extern:[txt.dir]nom"</span>
00189 <span class="comment"></span>
00190 <span class="comment">   (sur unix)filename = IdStrRemoveSuffix ("/usr/test.dir/nom.o");</span>
00191 <span class="comment"></span>
00192 <span class="comment">         =&gt; filename = "/usr/test.dir/nom"</span>
00193 <span class="comment"></span>
00194 <span class="comment">   (sur dos) filename = IdStrRemoveSuffix ("c:\ess.dir\nom.str");</span>
00195 <span class="comment"></span>
00196 <span class="comment">         =&gt; filename = "c:\ess.dir\nom"</span>
00197 <span class="comment"></span>
00198 <span class="comment">******************************************************** END DESCRIPTION */</span>
00199 
00207 <span class="keywordtype">char</span> *
<a name="l00208"></a><a class="code" href="str_8c.html#a1">00208</a> <a class="code" href="str_8c.html#a1">IdStrRemoveSuffix</a> ( <span class="keywordtype">char</span> *nom )
00209 {
00210   <span class="keywordtype">char</span>        * fin;
00211   <span class="keywordtype">char</span>        * nouveau;
00212   <span class="keywordtype">char</span>        * ajout;
00213   <span class="keywordtype">int</span>           car_copie;
00214   <span class="keywordtype">int</span>           taille;
00215 
00216                  <span class="comment">/* fin pointe sur fin du nom **/</span>
00217   <span class="keywordflow">for</span> ( fin = nom; *fin != <span class="charliteral">'\0'</span>; fin ++ );
00218                                           <span class="comment">/* cherche 1 '.' avant la fin */</span>
00219   <span class="keywordflow">for</span> ( ajout = fin; (*ajout!=<span class="charliteral">'.'</span>); ajout -- ) {
00220                                           <span class="comment">/* Pas de '.' trouve **********/</span>
00221     <span class="keywordflow">if</span> ( ajout &lt;= nom ) {
00222       ajout = fin ;
00223       <span class="keywordflow">break</span>;
00224     }
00225                                           <span class="comment">/* carac. interdit trouve *****/</span>
00226     <span class="keywordflow">if</span> (
00227 
00228 <span class="preprocessor">#if defined(_MSC_VER)</span>
00229 <span class="preprocessor"></span>        (*ajout==<span class="charliteral">':'</span>)||(*ajout==<span class="charliteral">'\\'</span>)
00230 <span class="preprocessor">#else</span>
00231 <span class="preprocessor"></span>        (*ajout==<span class="charliteral">'/'</span>)
00232 <span class="preprocessor">#endif</span>
00233 <span class="preprocessor"></span>
00234     ) {
00235       ajout = fin ;
00236       <span class="keywordflow">break</span>;
00237     }
00238   }
00239                  <span class="comment">/* calcul taille finale *******/</span>
00240   taille = (<span class="keywordtype">int</span>) (ajout-nom) + 1 ;
00241                  <span class="comment">/* et reservation memoire *****/</span>
00242   nouveau = (<span class="keywordtype">char</span> *)malloc (taille) ;
00243                  <span class="comment">/* copie du prefixe ***********/</span>
00244   <span class="keywordflow">for</span> ( car_copie = 0; nom &lt; ajout; car_copie ++ )
00245     nouveau[car_copie] = *(nom++);
00246                  <span class="comment">/* et ajout fin de chaine ********/</span>
00247  
00248     nouveau[car_copie++] = 0;
00249 
00250   <span class="keywordflow">return</span> nouveau;
00251 }
00252 
00253 
00254 
00255 
00256 
00257 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00258 <span class="comment"></span>
00259 <span class="comment">IdStrCreateUpperCase (fonction)</span>
00260 <span class="comment"></span>
00261 <span class="comment">RESUME: Renvoie une chaine en Majuscules  </span>
00262 <span class="comment"></span>
00263 <span class="comment">DESCRIPTION: Renvoie une chaine en Majuscules</span>
00264 <span class="comment"></span>
00265 <span class="comment">SYNTAXE:      char *nouvChaine = IdStrCreateUpperCase (char *ancChaine);</span>
00266 <span class="comment"></span>
00267 <span class="comment">RETOUR:      </span>
00268 <span class="comment">        type  : char *</span>
00269 <span class="comment">        role  : pointeur vers la zone allouee contenant la nouvelle</span>
00270 <span class="comment">           chaine</span>
00271 <span class="comment"></span>
00272 <span class="comment">PARAMETRES:  nom   : ancChaine</span>
00273 <span class="comment">        type  : char *</span>
00274 <span class="comment">        role  : pointeur sur l'ancienne chaine.</span>
00275 <span class="comment"></span>
00276 <span class="comment">FICHIER:     idstr.c</span>
00277 <span class="comment"></span>
00278 <span class="comment">EXEMPLES:    </span>
00279 <span class="comment">******************************************************** END DESCRIPTION */</span>
00280 
00281 <span class="comment">/**************************************************************************</span>
00282 <span class="comment">*                                                                         *</span>
00283 <span class="comment">* Nom de la fonction : Majuscule                                          *</span>
00284 <span class="comment">* Role ............. : Met une chaine de caracteres en majuscules.        *</span>
00285 <span class="comment">* Parametres ....... : Pointeur vers la chaine.                           *</span>
00286 <span class="comment">* Valeur retournee . : pointeur vers cette meme chaine en majuscule.      *</span>
00287 <span class="comment">*                                                                         *</span>
00288 <span class="comment">**************************************************************************/</span>
00289 
00297  <span class="keywordtype">char</span> *
<a name="l00298"></a><a class="code" href="str_8c.html#a2">00298</a> <a class="code" href="str_8c.html#a2">IdStrCreateUpperCase</a> (<span class="keywordtype">char</span> *chaine )
00299 {
00300   <span class="keywordtype">char</span> * ptr, *ptr2, *ptr3;
00301   ptr2 =(<span class="keywordtype">char</span> *)malloc(strlen(chaine)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)+1);
00302   ptr3=ptr2;
00303 
00304   <span class="keywordflow">for</span> ( ptr = chaine ; *ptr!=<span class="charliteral">'\0'</span> ; ptr ++ ) 
00305    {  *ptr3 = toupper ( * ptr ); ptr3++; 
00306    }
00307   *ptr3=<span class="charliteral">'\0'</span>;
00308  
00309   <span class="keywordflow">return</span> ptr2;
00310 }
00311 
00312 
00313 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00314 <span class="comment"></span>
00315 <span class="comment">IdStrSetUpperCase (fonction)</span>
00316 <span class="comment"></span>
00317 <span class="comment">RESUME: Transforme sur place une chaine en Majuscules</span>
00318 <span class="comment"></span>
00319 <span class="comment">DESCRIPTION: Transforme sur place une chaine en Majuscules</span>
00320 <span class="comment"></span>
00321 <span class="comment">SYNTAXE:      char *chaine = IdStrSetUpperCase (char *chaine);</span>
00322 <span class="comment"></span>
00323 <span class="comment">RETOUR:       type  : char *</span>
00324 <span class="comment">        role  : pointeur vers la zone contenant la chaine</span>
00325 <span class="comment"></span>
00326 <span class="comment">PARAMETRES:  nom   : chaine</span>
00327 <span class="comment">        type  : char *</span>
00328 <span class="comment">        role  : pointeur sur la chaine.</span>
00329 <span class="comment"></span>
00330 <span class="comment">FICHIER:     idstr.c</span>
00331 <span class="comment"></span>
00332 <span class="comment">EXEMPLES:</span>
00333 <span class="comment">    </span>
00334 <span class="comment">******************************************************** END DESCRIPTION */</span>
00335 
00336 
<a name="l00344"></a><a class="code" href="str_8c.html#a3">00344</a> <span class="keywordtype">char</span> * <a class="code" href="str_8c.html#a3">IdStrSetUpperCase</a> (<span class="keywordtype">char</span> *chaine )
00345 {
00346   <span class="keywordtype">char</span> *ptr;
00347   <span class="keywordflow">for</span> ( ptr = chaine ; *ptr!=<span class="charliteral">'\0'</span> ; *ptr = toupper (*ptr), ptr++ ) ; 
00348   <span class="keywordflow">return</span> chaine;
00349 }
00350 
00351 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00352 <span class="comment"></span>
00353 <span class="comment">IdStrCountChar (fonction)</span>
00354 <span class="comment"></span>
00355 <span class="comment">RESUME: Compte le nb d'occurrences d'1 caract ds une chaine</span>
00356 <span class="comment"></span>
00357 <span class="comment">DESCRIPTION:Compte le nb d'occurrences d'1 caract ds une chaine</span>
00358 <span class="comment"></span>
00359 <span class="comment">SYNTAXE:      int nbOccCaract = IdStrCountChar (char *chaine, char caract);</span>
00360 <span class="comment"></span>
00361 <span class="comment">RETOUR:      type  : int </span>
00362 <span class="comment">        role  : nb d'occurrences du caract ds la chaine</span>
00363 <span class="comment"></span>
00364 <span class="comment">PARAMETRES:  nom   : chaine</span>
00365 <span class="comment">        type  : char *</span>
00366 <span class="comment">        role  : pointeur sur la chaine.</span>
00367 <span class="comment">   </span>
00368 <span class="comment">        nom   : caract</span>
00369 <span class="comment">        type  : char </span>
00370 <span class="comment">        role  : caract compte</span>
00371 <span class="comment"></span>
00372 <span class="comment">FICHIER:     idstr.c</span>
00373 <span class="comment"></span>
00374 <span class="comment">EXEMPLES: </span>
00375 <span class="comment">   </span>
00376 <span class="comment">******************************************************** END DESCRIPTION */</span>
00385 <span class="keywordtype">int</span>
<a name="l00386"></a><a class="code" href="str_8c.html#a4">00386</a> <a class="code" href="str_8c.html#a4">IdStrCountChar</a> (<span class="keywordtype">char</span> *chaine, <span class="keywordtype">int</span> caract)
00387 {
00388   <span class="keywordtype">int</span> i=0;
00389   <span class="keywordtype">char</span> * ptr;
00390 
00391   <span class="keywordflow">for</span> ( ptr = chaine ; *ptr!=<span class="charliteral">'\0'</span> ; ptr ++ ) 
00392    {  <span class="keywordflow">if</span> (*ptr==caract) i++; 
00393    }
00394  
00395   <span class="keywordflow">return</span> i;
00396 }
00397 
00398 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00399 <span class="comment"></span>
00400 <span class="comment">IdStrDirName (fonction)</span>
00401 <span class="comment"></span>
00402 <span class="comment">RESUME: Extrait le DirectoryName d'un FullPathName</span>
00403 <span class="comment"></span>
00404 <span class="comment">DESCRIPTION: cree une chaine de caractere donnant le chemin fourni</span>
00405 <span class="comment">        sans non de fichier </span>
00406 <span class="comment"></span>
00407 <span class="comment">SYNTAXE:     char *dirOnly = IdStrDirName (char * path);</span>
00408 <span class="comment"></span>
00409 <span class="comment">RETOUR:      type  : char *</span>
00410 <span class="comment">        role  : pointeur vers la zone allouee contenant le</span>
00411 <span class="comment">           DirectoryName</span>
00412 <span class="comment"></span>
00413 <span class="comment">PARAMETRES:  nom   : path</span>
00414 <span class="comment">        type  : char *</span>
00415 <span class="comment">        role  : chemin fourni</span>
00416 <span class="comment"></span>
00417 <span class="comment">FICHIER:     idstr.c</span>
00418 <span class="comment"></span>
00419 <span class="comment">EXEMPLE:    nom_fichier = IdStrDirName("/rep1/rep2/toto.truc");</span>
00420 <span class="comment">               renvoie "/rep1/rep2/"</span>
00421 <span class="comment"></span>
00422 <span class="comment">******************************************************** END DESCRIPTION */</span>
00423 
00431 <span class="keywordtype">char</span> *
<a name="l00432"></a><a class="code" href="str_8c.html#a5">00432</a> <a class="code" href="str_8c.html#a5">IdStrDirName</a> (<span class="keywordtype">char</span> * nom )
00433 {
00434 
00435   <span class="keywordtype">char</span>      *fin, *pnomfic, *nouveau, *debnouveau;
00436   <span class="keywordtype">int</span>       taille;
00437                  <span class="comment">/* fin pointe sur fin du nom */</span>
00438   <span class="keywordflow">for</span> ( fin = nom; *fin != <span class="charliteral">'\0'</span>; fin ++ );
00439                                           <span class="comment">/* cherche '/' ou '\' avant la fin */</span>
00440   <span class="keywordflow">for</span> ( pnomfic = fin;
00441 <span class="preprocessor">#if defined(_MSC_VER)</span>
00442 <span class="preprocessor"></span>                         *pnomfic != <span class="charliteral">'\\'</span>; 
00443 <span class="preprocessor">#else</span>
00444 <span class="preprocessor"></span>                         *pnomfic != <span class="charliteral">'/'</span>;
00445 <span class="preprocessor">#endif</span>
00446 <span class="preprocessor"></span>                pnomfic -- )
00447     {
00448                                           <span class="comment">/* pas de '\' ou '/' trouve */</span>
00449     <span class="keywordflow">if</span> ( pnomfic == nom ) <span class="keywordflow">break</span>;
00450     }
00451 
00452   <span class="keywordflow">if</span> (pnomfic != nom)           <span class="comment">/* si rep present */</span>
00453   {
00454                  <span class="comment">/* calcul taille finale */</span>
00455     taille = (<span class="keywordtype">int</span>) (pnomfic - nom) + 2;
00456                  <span class="comment">/* et reservation memoire */</span>  
00457     nouveau = debnouveau = (<span class="keywordtype">char</span> *) malloc (taille);
00458                  <span class="comment">/* copie du path */</span>
00459     <span class="keywordflow">for</span> ( ; nom &lt;= pnomfic; *(nouveau++) = *(nom++) );
00460   }
00461   <span class="keywordflow">else</span> nouveau = debnouveau = (<span class="keywordtype">char</span> *) malloc (1);
00462                  <span class="comment">/* ajoute fin */</span>
00463   *nouveau = <span class="charliteral">'\0'</span>;
00464 
00465   <span class="keywordflow">return</span> debnouveau;
00466 }
00467 
00468 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00469 <span class="comment"></span>
00470 <span class="comment">IdStrFileName (fonction)</span>
00471 <span class="comment"></span>
00472 <span class="comment">RESUME: Extrait le FileName d'un FullPathName</span>
00473 <span class="comment"></span>
00474 <span class="comment">DESCRIPTION: cree une chaine de caractere donnant le dernier nom trouve dans</span>
00475 <span class="comment">        le chemin d'acces fourni </span>
00476 <span class="comment"></span>
00477 <span class="comment">SYNTAXE:     char *lastName = IdStrFileName (char * path);</span>
00478 <span class="comment"></span>
00479 <span class="comment">RETOUR:      type  : char *</span>
00480 <span class="comment">        role  : pointeur vers la zone allouee contenant le</span>
00481 <span class="comment">           nom de fichier.</span>
00482 <span class="comment"></span>
00483 <span class="comment">PARAMETRES:  nom   : path</span>
00484 <span class="comment">        type  : char *</span>
00485 <span class="comment">        role  : chemin fourni</span>
00486 <span class="comment"></span>
00487 <span class="comment">FICHIER:     idstr.c</span>
00488 <span class="comment"></span>
00489 <span class="comment">EXEMPLE:    nom_fichier = IdStrFileName("/rep1/rep2/toto.truc");</span>
00490 <span class="comment"></span>
00491 <span class="comment">******************************************************** END DESCRIPTION */</span>
00492 
00500 <span class="keywordtype">char</span> *
<a name="l00501"></a><a class="code" href="str_8c.html#a6">00501</a> <a class="code" href="str_8c.html#a6">IdStrFileName</a> (<span class="keywordtype">char</span> * nom )
00502 {
00503   <span class="keywordtype">char</span>        *fin, *pnomfic, *nouveau, *debnouveau;
00504   <span class="keywordtype">int</span>         taille;
00505                  <span class="comment">/* fin pointe sur fin du nom */</span>
00506   <span class="keywordflow">for</span> ( fin = nom; *fin != <span class="charliteral">'\0'</span>; fin ++ );
00507                                           <span class="comment">/* cherche '/' ou '\' avant la fin */</span>
00508   <span class="keywordflow">for</span> ( pnomfic = fin;
00509 
00510 <span class="preprocessor">#if defined(_MSC_VER)</span>
00511 <span class="preprocessor"></span>                         *pnomfic != <span class="charliteral">'\\'</span>; 
00512 <span class="preprocessor">#else</span>
00513 <span class="preprocessor"></span>                         *pnomfic != <span class="charliteral">'/'</span>;
00514 <span class="preprocessor">#endif</span>
00515 <span class="preprocessor"></span>                pnomfic -- )
00516   {
00517                                           <span class="comment">/* pas de '\' ou '/' trouve */</span>
00518     <span class="keywordflow">if</span> ( pnomfic == nom )
00519     {
00520       pnomfic --;
00521       <span class="keywordflow">break</span>;
00522     }
00523   }
00524                  <span class="comment">/* calcul taille finale */</span>
00525   taille = (<span class="keywordtype">int</span>) (fin - (++ pnomfic)) + 1; 
00526                  <span class="comment">/* et reservation memoire */</span>  
00527   nouveau = debnouveau = (<span class="keywordtype">char</span> *) malloc (taille);
00528                  <span class="comment">/* copie du nom */</span>
00529   <span class="keywordflow">for</span> ( ; pnomfic &lt;= fin; ) *(nouveau++) = *(pnomfic++);
00530 
00531   <span class="keywordflow">return</span> debnouveau;
00532 }
00533 
00534 
00535 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00536 <span class="comment"></span>
00537 <span class="comment">IdStrMakeFullPathName (fonction)</span>
00538 <span class="comment"></span>
00539 <span class="comment">RESUME: Fabrique le FullPathName d'un Fichier</span>
00540 <span class="comment"></span>
00541 <span class="comment">DESCRIPTION: cree une chaine de caractere donnant le nom hierachique complet</span>
00542 <span class="comment">        </span>
00543 <span class="comment">SYNTAXE:     char *FullPathName = IdStrFileName (char * dirName, char * fileName);</span>
00544 <span class="comment"></span>
00545 <span class="comment">RETOUR:      type  : char *</span>
00546 <span class="comment">        role  : pointeur vers la zone allouee contenant le</span>
00547 <span class="comment">           nom de fichier.</span>
00548 <span class="comment"></span>
00549 <span class="comment">PARAMETRES:  nom   : dirName</span>
00550 <span class="comment">        type  : char *</span>
00551 <span class="comment">        role  : nom Dir</span>
00552 <span class="comment"></span>
00553 <span class="comment">        nom   : fileName</span>
00554 <span class="comment">        type  : char *</span>
00555 <span class="comment">        role  : nom Fich</span>
00556 <span class="comment">FICHIER:     idstr.c</span>
00557 <span class="comment"></span>
00558 <span class="comment">EXEMPLE:    nom_fichier = IdStrMakeFullPathName("/rep1/rep2/toto","truc");</span>
00559 <span class="comment"></span>
00560 <span class="comment">******************************************************** END DESCRIPTION */</span>
00561 
00570 <span class="keywordtype">char</span> *
<a name="l00571"></a><a class="code" href="str_8c.html#a7">00571</a> <a class="code" href="str_8c.html#a7">IdStrMakeFullPathName</a> (<span class="keywordtype">char</span> *  dirName,<span class="keywordtype">char</span> *  fileName )
00572 {
00573   <span class="keywordtype">char</span>        *FullPathName;
00574   <span class="keywordtype">int</span>         taille;
00575 
00576 
00577    <span class="keywordflow">if</span>(dirName) {
00578       taille=strlen(dirName)+strlen(fileName)+1;
00579       } <span class="keywordflow">else</span> {
00580       taille=strlen(fileName)+1; 
00581       }
00582    FullPathName=(<span class="keywordtype">char</span> *) malloc(taille+1);
00583    <span class="keywordflow">if</span> (!FullPathName) { 
00584       printf(<span class="stringliteral">"IdStrMakeFullPathName : impossible allouer FullPathName\n"</span>);
00585       <span class="keywordflow">return</span> (NULL);
00586    }
00587    
00588    <span class="keywordflow">if</span> (strlen(dirName)!=0) {
00589 <span class="preprocessor">#if defined(_MSC_VER) </span>
00590 <span class="preprocessor"></span>      sprintf(FullPathName,<span class="stringliteral">"%s\\%s"</span>,dirName,fileName); 
00591 <span class="preprocessor">#else</span>
00592 <span class="preprocessor"></span>      sprintf(FullPathName,<span class="stringliteral">"%s/%s"</span>,dirName,fileName); 
00593 <span class="preprocessor">#endif</span>
00594 <span class="preprocessor"></span>   } <span class="keywordflow">else</span> {
00595       sprintf(FullPathName,<span class="stringliteral">"%s"</span>,fileName); 
00596    }
00597 
00598    <span class="keywordflow">return</span> FullPathName;
00599 }
00600 
00601 
00602 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00603 <span class="comment"></span>
00604 <span class="comment">IdStrIntEnum (fonction)</span>
00605 <span class="comment"></span>
00606 <span class="comment">RESUME: renvoie 1 tableau contenant une liste d'intervalles entiers</span>
00607 <span class="comment"></span>
00608 <span class="comment">DESCRIPTION:renvoie 1 tableau contenant une liste d'intervalles entiers </span>
00609 <span class="comment"></span>
00610 <span class="comment">SYNTAXE:     int [] TabInterv= IdStrIntEnum (char * chaine, int * nbInterv);</span>
00611 <span class="comment"></span>
00612 <span class="comment">RETOUR:      type  : int *</span>
00613 <span class="comment">        role  : pointeur vers la zone allouee contenant les</span>
00614 <span class="comment">           intervalles (deb1,fin1, deb2,fin2, ...)</span>
00615 <span class="comment"></span>
00616 <span class="comment">PARAMETRES:  nom   : path</span>
00617 <span class="comment">        type  : char *</span>
00618 <span class="comment">        role  : chaine caract a decoder</span>
00619 <span class="comment"></span>
00620 <span class="comment">      nom   : nbInterv</span>
00621 <span class="comment">      type  : int *</span>
00622 <span class="comment">      role  : nb d'interv trouves</span>
00623 <span class="comment"></span>
00624 <span class="comment">FICHIER:     idstr.c</span>
00625 <span class="comment"></span>
00626 <span class="comment">EXEMPLE:   </span>
00627 <span class="comment"></span>
00628 <span class="comment">******************************************************** END DESCRIPTION */</span>
00629 
00630 
00641 <span class="keywordtype">int</span> *
<a name="l00642"></a><a class="code" href="str_8c.html#a8">00642</a> <a class="code" href="str_8c.html#a8">IdStrIntEnum</a> ( <span class="keywordtype">char</span>*value, <span class="keywordtype">int</span> *number)
00643 
00644 {
00645   <span class="keywordtype">int</span>* liste;
00646   <span class="keywordtype">int</span> taille;
00647   <span class="keywordtype">int</span> i;
00648 
00649   *number = <a class="code" href="str_8c.html#a4">IdStrCountChar</a>(value,<span class="charliteral">','</span>)+1; <span class="comment">/* nb Elements = nb Virgules +1 */</span>
00650   taille= *number;
00651 <span class="comment">/* printf ("taille %d\n",taille); */</span>
00652   liste = (<span class="keywordtype">int</span> *) calloc (2*taille , <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00653   <span class="keywordflow">if</span> ( !liste ) {
00654     <a class="code" href="iderr_8h.html#a65">IdErrno</a> = <a class="code" href="iderr_8h.html#a26">IDERR_ALLOC_MEM</a>;
00655     <span class="keywordflow">return</span> 0;
00656   }
00657 
00658 i=0;
00659 
00660   <span class="keywordflow">while</span> ( taille&gt;0 ) {
00661     liste[i] = (<span class="keywordtype">int</span>) strtol ( value, &amp;value, 10 );
00662       
00663     <span class="keywordflow">if</span> ( *value == <span class="charliteral">'\0'</span> ) 
00664       {
00665       liste[i+1]=liste[i];
00666       <span class="keywordflow">return</span> liste;
00667       }
00668 
00669     <span class="keywordflow">if</span> ( *(value++) != <span class="charliteral">'-'</span> )  {
00670          liste[i+1]=liste[i];
00671          value--;
00672             }
00673       <span class="keywordflow">else</span>     {
00674          liste[i+1] = (<span class="keywordtype">int</span>) strtol ( value, &amp;value, 10 );
00675             }
00676     <span class="keywordflow">if</span> ( *value == <span class="charliteral">'\0'</span> ) <span class="keywordflow">return</span> liste;
00677 
00678     <span class="keywordflow">if</span> ( *(value++) != <span class="charliteral">','</span> ) {
00679       free (liste);
00680       <a class="code" href="iderr_8h.html#a65">IdErrno</a> = <a class="code" href="iderr_8h.html#a10">IDERR_NOT_INTLIST</a>;
00681       <span class="keywordflow">return</span> 0;
00682     }
00683     taille --; i+=2;
00684   }
00685 <span class="keywordflow">return</span> liste;
00686 
00687 }
00688 
00689 
00690 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00691 <span class="comment"></span>
00692 <span class="comment">IdStrFloatEnum (fonction) </span>
00693 <span class="comment"></span>
00694 <span class="comment">RESUME: renvoie 1 tableau  contenant une liste d'intervalles FLOAT</span>
00695 <span class="comment"></span>
00696 <span class="comment">DESCRIPTION:renvoie 1 tableau  contenant une liste d'intervalles entiers </span>
00697 <span class="comment"></span>
00698 <span class="comment">SYNTAXE:     float [] TabInterv= IdStrFloatEnum (char * chaine, int * nbInterv);</span>
00699 <span class="comment"></span>
00700 <span class="comment">RETOUR:      type  : char *</span>
00701 <span class="comment">        role  : pointeur vers la zone allouee contenant le</span>
00702 <span class="comment">           nom de fichier.</span>
00703 <span class="comment"></span>
00704 <span class="comment">PARAMETRES:  nom   : path</span>
00705 <span class="comment">        type  : char *</span>
00706 <span class="comment">        role  : chaine caract a decoder</span>
00707 <span class="comment"></span>
00708 <span class="comment">      nom   : nbInterv</span>
00709 <span class="comment">      type  : int *</span>
00710 <span class="comment">      role  : nb d'interv trouves</span>
00711 <span class="comment"></span>
00712 <span class="comment">FICHIER:     idstr.c</span>
00713 <span class="comment"></span>
00714 <span class="comment">EXEMPLE:   </span>
00715 <span class="comment"></span>
00716 <span class="comment">******************************************************** END DESCRIPTION */</span>
00727 <span class="keywordtype">float</span> *
<a name="l00728"></a><a class="code" href="str_8c.html#a9">00728</a> <a class="code" href="str_8c.html#a9">IdStrFloatEnum</a> (<span class="keywordtype">char</span>*  value, <span class="keywordtype">int</span> * number)
00729 {
00730   <span class="keywordtype">float</span>* liste;
00731   <span class="keywordtype">int</span> taille;
00732   <span class="keywordtype">int</span> i;
00733 
00734   *number = <a class="code" href="str_8c.html#a4">IdStrCountChar</a>(value,<span class="charliteral">','</span>)+1; <span class="comment">/* nb Elements = nb Virgules +1 */</span>
00735   taille= *number;
00736 <span class="comment">/* printf ("taille %d\n",taille); */</span>
00737   liste = (<span class="keywordtype">float</span> *) calloc (2*taille , <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
00738   <span class="keywordflow">if</span> ( !liste ) {
00739     <a class="code" href="iderr_8h.html#a65">IdErrno</a> = <a class="code" href="iderr_8h.html#a26">IDERR_ALLOC_MEM</a>;
00740     <span class="keywordflow">return</span> 0;
00741   }
00742 
00743 i=0;
00744 
00745   <span class="keywordflow">while</span> ( taille&gt;0 ) {
00746     liste[i] = (<span class="keywordtype">float</span>) strtod ( value, &amp;value );
00747       
00748     <span class="keywordflow">if</span> ( *value == <span class="charliteral">'\0'</span> ) 
00749       {
00750       liste[i+1]=liste[i];
00751       <span class="keywordflow">return</span> liste;
00752       }
00753 
00754     <span class="keywordflow">if</span> ( *(value++) != <span class="charliteral">'-'</span> )  {
00755          liste[i+1]=liste[i];
00756          value--;
00757             }
00758       <span class="keywordflow">else</span>     {
00759          liste[i+1] = (<span class="keywordtype">float</span>) strtod ( value, &amp;value );
00760             }
00761     <span class="keywordflow">if</span> ( *value == <span class="charliteral">'\0'</span> ) <span class="keywordflow">return</span> liste;
00762 
00763     <span class="keywordflow">if</span> ( *(value++) != <span class="charliteral">','</span> ) {
00764       free (liste);
00765       <a class="code" href="iderr_8h.html#a65">IdErrno</a> = <a class="code" href="iderr_8h.html#a10">IDERR_NOT_INTLIST</a>;
00766       <span class="keywordflow">return</span> 0;
00767     }
00768     taille --; i+=2;
00769   }
00770 <span class="keywordflow">return</span> liste;
00771 
00772 }
00773 
00774 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00775 <span class="comment"></span>
00776 <span class="comment">IdStrSwap (fonction) </span>
00777 <span class="comment"></span>
00778 <span class="comment">RESUME: renvoie l'entier correspondant au Swap des pixels</span>
00779 <span class="comment"></span>
00780 <span class="comment">DESCRIPTION: renvoie l'entier correspondant au Swap des pixels </span>
00781 <span class="comment"></span>
00782 <span class="comment">SYNTAXE:     int typeSwap= IdStrSwap (char * chaine);</span>
00783 <span class="comment"></span>
00784 <span class="comment">RETOUR:      type  : int</span>
00785 <span class="comment">        role  : entier correspondant au Swap des pixels.</span>
00786 <span class="comment">         "O"    -&gt; 2143  SHORT, USHORT</span>
00787 <span class="comment">         "o"    -&gt; 2143</span>
00788 <span class="comment">         "N"    -&gt; 1234</span>
00789 <span class="comment">         "n"    -&gt; 1234</span>
00790 <span class="comment"></span>
00791 <span class="comment">         "1234"    -&gt; 1234  LONG, ULONG</span>
00792 <span class="comment">         "2143"    -&gt; 2143</span>
00793 <span class="comment">         "3412"    -&gt; 3412</span>
00794 <span class="comment">         "4321"    -&gt; 4321</span>
00795 <span class="comment"></span>
00796 <span class="comment">PARAMETRES:  nom   : chaine</span>
00797 <span class="comment">        type  : char *</span>
00798 <span class="comment">        role  : chaine caract a decoder</span>
00799 <span class="comment"></span>
00800 <span class="comment">FICHIER:     idstr.c</span>
00801 <span class="comment"></span>
00802 <span class="comment">EXEMPLE:   </span>
00803 <span class="comment"></span>
00804 <span class="comment">******************************************************** END DESCRIPTION */</span>
<a name="l00812"></a><a class="code" href="str_8c.html#a10">00812</a> <span class="keywordtype">int</span> <a class="code" href="str_8c.html#a10">IdStrSwap</a> (<span class="keywordtype">char</span> *chaine)
00813 {
00814 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"O"</span>)==0)  <span class="keywordflow">return</span> 2143;
00815 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"Y"</span>)==0)  <span class="keywordflow">return</span> 2143;
00816 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"N"</span>)==0)  <span class="keywordflow">return</span> 1234;
00817 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"1234"</span>)==0)  <span class="keywordflow">return</span> 1234;
00818 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"ABCD"</span>)==0)  <span class="keywordflow">return</span> 1234;
00819 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"2143"</span>)==0)  <span class="keywordflow">return</span> 2143;
00820 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"BADC"</span>)==0)  <span class="keywordflow">return</span> 2143;
00821 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"3412"</span>)==0)  <span class="keywordflow">return</span> 3412;
00822 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"CDAB"</span>)==0)  <span class="keywordflow">return</span> 3412;
00823 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"4321"</span>)==0)  <span class="keywordflow">return</span> 4321;
00824 <span class="keywordflow">if</span> (<a class="code" href="strcomp_8c.html#a1">IdStrCmpNoCase</a>(chaine,<span class="stringliteral">"DCBA"</span>)==0)  <span class="keywordflow">return</span> 4321;
00825 
00826 <span class="keywordflow">return</span> 0;
00827 }
00828 
00829 
00830 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00831 <span class="comment">* </span>
00832 <span class="comment">* IdStrSort    (fonction)</span>
00833 <span class="comment">* </span>
00834 <span class="comment">* RESUME: Tri d'un tableau de pointeurs sur N'IMPORTE QUOI, sur N'IMPORTE QUEL critere</span>
00835 <span class="comment">* </span>
00836 <span class="comment">* DESCRIPTION:  Tri d'un tableau de pointeurs sur N'IMPORTE QUOI, </span>
00837 <span class="comment">*     sur N'IMPORTE QUEL critere.</span>
00838 <span class="comment">*     (Methode de Shell-Metzner)</span>
00839 <span class="comment">*     La fonction de comparaison de deux objets </span>
00840 <span class="comment">*     est a la charge de l'utilisateur.</span>
00841 <span class="comment">*     (lui seul connait leur structure, et le critere de tri)</span>
00842 <span class="comment">* </span>
00843 <span class="comment">* SYNTAXE: IdStrSort ( void *tab,  int (*foncComparObj)(void * ptrObj1, void * ptrObj2);</span>
00844 <span class="comment">* </span>
00845 <span class="comment">* </span>
00846 <span class="comment">* RETOUR:      type  : aucun</span>
00847 <span class="comment">*  </span>
00848 <span class="comment">* PARAMETRES:  nom   : tab</span>
00849 <span class="comment">*     type  : void *</span>
00850 <span class="comment">*     role  : tableau de pointeurs sur N'IMPORTE QUOI</span>
00851 <span class="comment">* </span>
00852 <span class="comment">*     nom   : n</span>
00853 <span class="comment">*     type  : int</span>
00854 <span class="comment">*     role  : nb d'elements du tableau</span>
00855 <span class="comment">* </span>
00856 <span class="comment">*     nom   : foncComparObj</span>
00857 <span class="comment">*     type  : pointeur sur fonction</span>
00858 <span class="comment">*     role  : Fonction de comparaison de deux Objets</span>
00859 <span class="comment">*        retourne -1  si 1 er &lt; 2 eme</span>
00860 <span class="comment">*              0   si 1 er = 2 eme</span>
00861 <span class="comment">*              +1  si 1 er &gt; 2 eme</span>
00862 <span class="comment">*              -2  si les deux Objets </span>
00863 <span class="comment">*                 NE SONT PAS comparables</span>
00864 <span class="comment">* </span>
00865 <span class="comment">* FICHIER:   idstr.c    </span>
00866 <span class="comment">* </span>
00867 <span class="comment">* EXEMPLE:  Soit le tableau T1, de pointeurs vers des 'Objets'</span>
00868 <span class="comment">*    qui sont des tableaux de chaines de caracteres</span>
00869 <span class="comment">*   le critere de tri est la chaine num 16 du tableau ...</span>
00870 <span class="comment">* </span>
00871 <span class="comment">*  on triera comme suit:</span>
00872 <span class="comment">* </span>
00873 <span class="comment">*  int comp (void *, void *);</span>
00874 <span class="comment">*  IdStrSort(T1, comp); </span>
00875 <span class="comment">* </span>
00876 <span class="comment">* avec :</span>
00877 <span class="comment">*  </span>
00878 <span class="comment">* int comp (a, b)</span>
00879 <span class="comment">* void *a, *b;</span>
00880 <span class="comment">* {</span>
00881 <span class="comment">*  int i;</span>
00882 <span class="comment">*  i=strcmp( ((char **)a)[16],((char **)b)[16]);</span>
00883 <span class="comment">*  if      (i&lt;0) i=-1;</span>
00884 <span class="comment">*  else if (i&gt;0) i= 1;</span>
00885 <span class="comment">*  return i;</span>
00886 <span class="comment">* }</span>
00887 <span class="comment">*   </span>
00888 <span class="comment">* </span>
00889 <span class="comment">******************************************************** END DESCRIPTION */</span>
00890 
<a name="l00900"></a><a class="code" href="str_8c.html#a11">00900</a> <span class="keywordtype">int</span> * <a class="code" href="str_8c.html#a11">IdStrSort</a> (<span class="keywordtype">void</span> **tab, <span class="keywordtype">int</span> n,
00901                 INT_FUNCTION_VOIDP_VOIDP_POINTER foncComparObj)
00902 {
00903    <span class="keywordtype">int</span> i,j,m;
00904    <span class="keywordtype">void</span> *<a class="code" href="jpegint_8h.html#a21">b</a>;
00905    <span class="keywordtype">int</span> *tabInd =(<span class="keywordtype">int</span> *) malloc(n*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00906    <span class="keywordflow">if</span> (!tabInd) 
00907       <span class="keywordflow">return</span> NULL;
00908    <span class="keywordflow">for</span>(i=0;i&lt;n;i++) 
00909       tabInd[i]=i;
00910    
00911    <span class="comment">//  Shell-Metzner' Method</span>
00912    
00913    m=1;
00914    <span class="keywordflow">do</span> {
00915       m = 3*m+1;
00916    } <span class="keywordflow">while</span>(m &lt;= n);
00917    <span class="keywordflow">do</span> {
00918       m = m/3;
00919       <span class="keywordflow">for</span> (i=m; i&lt;n; i++) {
00920          j = i-m;
00921          <a class="code" href="jpegint_8h.html#a21">b</a> = tab[i];
00922          <span class="keywordflow">while</span>( foncComparObj(tab[tabInd[j]],<a class="code" href="jpegint_8h.html#a21">b</a>)==1) {
00923             tab[tabInd[j+m]] = tab[tabInd[j]];
00924             j = j-m;
00925             <span class="keywordflow">if</span> (j&lt;0) <span class="keywordflow">break</span>;
00926          }
00927          tab[j+m] = <a class="code" href="jpegint_8h.html#a21">b</a>;
00928       }
00929    }<span class="keywordflow">while</span> (m&gt;1);
00930    
00931   <span class="keywordflow">return</span> (tabInd);
00932    
00933 }
00934 
00935 <span class="comment">/* FUNCTION DESCRIPTION **************************************************</span>
00936 <span class="comment"></span>
00937 <span class="comment">IdStrPatternMatching (fonction) </span>
00938 <span class="comment"></span>
00939 <span class="comment">RESUME: Teste la concordance d'une chaine de caract a un masque</span>
00940 <span class="comment"></span>
00941 <span class="comment">DESCRIPTION: Teste la concordance d'une chaine de caract a un masque </span>
00942 <span class="comment">      (caractere JOKER : * )</span>
00943 <span class="comment"></span>
00944 <span class="comment">SYNTAXE:     int retCode= IdStrPatternMatching (char * chaine, char *masque);</span>
00945 <span class="comment"></span>
00946 <span class="comment">RETOUR:      type  : int</span>
00947 <span class="comment">        role  : pointeur vers la zone allouee contenant le</span>
00948 <span class="comment">           nom de fichier.</span>
00949 <span class="comment"></span>
00950 <span class="comment">PARAMETRES:  nom   : chaine</span>
00951 <span class="comment">        type  : char *</span>
00952 <span class="comment">        role  : chaine caract a decoder</span>
00953 <span class="comment"></span>
00954 <span class="comment">        nom   : masque</span>
00955 <span class="comment">        type  : char *</span>
00956 <span class="comment">        role  : masque de concordance</span>
00957 <span class="comment"></span>
00958 <span class="comment">FICHIER:     idstr.c</span>
00959 <span class="comment"></span>
00960 <span class="comment">EXEMPLE:   bool = IdStrPatternMatching (fileName, *.ima);</span>
00961 <span class="comment"></span>
00962 <span class="comment">******************************************************** END DESCRIPTION */</span>
00963 <span class="keywordtype">int</span>
<a name="l00964"></a><a class="code" href="str_8c.html#a12">00964</a> <a class="code" href="str_8c.html#a12">IdStrPatternMatching</a> (<span class="keywordtype">char</span> *  chaine, <span class="keywordtype">char</span> * masque )
00965 {
00966   <span class="keywordtype">int</span>     taille, nbElem, i;
00967   <span class="keywordtype">char</span> ** liste;
00968   <span class="keywordtype">char</span> ** elem;
00969   <span class="keywordtype">char</span> *  chainecur;
00970   <span class="keywordtype">char</span> *  ptrDeb;
00971 
00972   <span class="keywordflow">if</span> (!masque) {    
00973    <a class="code" href="iderr_8h.html#a65">IdErrno</a> = <a class="code" href="iderr_8h.html#a7">IDERR_LABEL_UNDEF</a>;
00974       <span class="keywordflow">return</span> 0;
00975   }
00976 
00977   nbElem = <a class="code" href="str_8c.html#a4">IdStrCountChar</a>(masque,<span class="charliteral">'*'</span>);
00978 
00979   <span class="keywordflow">if</span> (masque[0]                == <span class="charliteral">'*'</span>) nbElem--;
00980   <span class="keywordflow">if</span> (masque[strlen(masque)-1] != <span class="charliteral">'*'</span>) nbElem++;
00981 
00982   taille = nbElem;
00983 
00984   liste = (<span class="keywordtype">char</span> **) malloc (<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*) * taille + strlen(masque)+1);
00985   <span class="keywordflow">if</span> ( !liste ) {
00986     <a class="code" href="iderr_8h.html#a65">IdErrno</a> = <a class="code" href="iderr_8h.html#a26">IDERR_ALLOC_MEM</a>;
00987     <span class="keywordflow">return</span> 0;
00988   }
00989 
00990   masque = strcpy( ((<span class="keywordtype">char</span>*)liste)+<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*) * taille, masque );
00991 
00992   <span class="keywordflow">for</span> ( elem = liste, chainecur = strtok(masque,<span class="stringliteral">"*"</span>);
00993    taille&gt;0;
00994    taille--, chainecur = (chainecur) ? strtok ( 0, <span class="stringliteral">"*"</span> ) : 0 )
00995   {
00996     *(elem++) = chainecur;
00997   }
00998 
00999 <span class="comment">/*printf ("fin Rech :nbElem %d \n",nbElem);     */</span>
01000 <span class="comment">/*for(i=0;i&lt;nbElem;i++) printf ("&gt;%s&lt;\n",liste[i]);   */</span>
01001 
01002 ptrDeb=chaine;
01003 <span class="keywordflow">for</span>(i=0;i&lt;nbElem;i++) 
01004    {
01005    ptrDeb=strstr(ptrDeb,liste[i]);
01006    <span class="keywordflow">if</span> (!ptrDeb) <span class="keywordflow">return</span>(0);
01007    ptrDeb=ptrDeb + strlen(liste[i]) - 1;
01008    }
01009 
01010 <span class="comment">/*</span>
01011 <span class="comment">printf ("ptrDeb %x chaine %x strlen(chaine) %d \n", ptrDeb,chaine,strlen(chaine));</span>
01012 <span class="comment">*/</span>
01013 
01014 <span class="keywordflow">if</span>(ptrDeb != chaine+strlen(chaine)-1 ) <span class="keywordflow">return</span> 0;
01015        
01016 <span class="keywordflow">return</span> 1;
01017 }
01018 
01019 
<a name="l01029"></a><a class="code" href="str_8c.html#a13">01029</a> <span class="keywordtype">char</span> * <a class="code" href="str_8c.html#a13">IdStrCleanName</a> (<span class="keywordtype">char</span> * nom)
01030 {
01031    <span class="keywordtype">char</span> *ptr, *ptr2, *ptrSecu;
01032    <span class="keywordtype">int</span> indJpr;
01033 
01034       ptr=nom;
01035       ptr2=ptrSecu=(<span class="keywordtype">char</span> *) malloc(strlen(nom)+1);
01036       indJpr=0;
01037       <span class="keywordflow">while</span>(*ptr != 0) 
01038       { 
01039          <span class="keywordflow">if</span> (0) 
01040          { 
01041             indJpr ++; 
01042             printf (<span class="stringliteral">"%d : %c %x\n"</span>,indJpr,*ptr,*ptr); 
01043          }
01044          <span class="keywordflow">if</span>(*ptr != <span class="charliteral">' '</span>) 
01045          { 
01046             <span class="keywordflow">if</span>( (*ptr == <span class="charliteral">'/'</span>) || (*ptr == <span class="charliteral">'\\'</span>) || (*ptr == <span class="charliteral">'\''</span>) || (*ptr == 0x5e)) 
01047             { 
01048                *ptr2++ = <span class="charliteral">'_'</span>;
01049                *ptr++; 
01050             } 
01051             <span class="keywordflow">else</span>
01052                *ptr2++ = *ptr++;
01053          }
01054          <span class="keywordflow">else</span> 
01055             ptr++;
01056       }
01057       *ptr2++=0;
01058 
01059    <span class="keywordflow">return</span>(ptrSecu);
01060 }
01061 
<a name="l01070"></a><a class="code" href="str_8c.html#a14">01070</a> <span class="keywordtype">char</span> * <a class="code" href="str_8c.html#a14">_IdStrShowTransfertSyntax</a> (<span class="keywordtype">char</span> * codeTransfSynt) {
01071    <span class="keywordtype">int</span> i;
01072    <span class="keywordtype">int</span> nbTransfSynt=23; <span class="comment">// voir dicom.c, Sorry</span>
01073    <span class="keywordflow">for</span>(i=0; i&lt;nbTransfSynt; i++) {
01074       <span class="keywordflow">if</span>( strcmp(codeTransfSynt, <a class="code" href="dicom_8c.html#a4">_ID_transfert_syntax</a>[i].transf_synt_code) == 0 ) 
01075       <span class="keywordflow">return</span>(<a class="code" href="dicom_8c.html#a4">_ID_transfert_syntax</a>[i].<a class="code" href="struct____transfert__syntax____.html#o0">transf_synt_libelle</a>);
01076    }
01077    
01078    printf(<span class="stringliteral">"code Transfert Syntax inconnu : [%s]\n"</span>,codeTransfSynt);
01079    
01080    <span class="keywordflow">return</span>(<span class="stringliteral">"code Transfert Syntax inconnu"</span>);
01081 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 20 14:28:15 2006 for SIMRI3D by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
